[{"id":0,"href":"/docs/switch/basic_knowledge/","title":"List of Basic Knowledge","section":"ZIGGO Switch","content":"\rList of Basic Knowledge\r#\rWe reiterate that using or developing ZIGGO-CaaS-Switch or ZIGGO-Device has a high threshold; you must have certain hardware and software knowledge. If you have no previous experience in hardware development, you may need to carefully consider whether you are suitable for this project, as learning these skills is very time-consuming.\nLearning to use the ZIGGO project demands higher requirements than traditional development tools like FPGA, MCU, ARM, etc. Mastering ZIGGO devices is not something that can be achieved overnight.\nIf you wish to use the ZIGGO project, you should at least have the following knowledge:\nHardware Knowledge\r#\rPrinciples of Computer Organization C Language Fundamentals of Digital Circuits Verilog, VHDL languages Good foundation in English reading Software Knowledge\r#\rPrinciples of Computer Organization Computer Networks Computer Operating Systems C, C++ Languages tcl Scripts Good foundation in English reading "},{"id":1,"href":"/docs/tsnperf/principle/","title":"TSNPerf Design Principles","section":"ZIGGO TSNPerf","content":"\rTSNPerf Design Principles\r#\rLimitations of Existing Solutions\r#\rTSNPerf is a performance evaluation tool specifically designed for Time-Sensitive Networking (TSN). It provides comprehensive performance evaluation capabilities for TSN networks, helping network engineers and researchers to deeply understand and verify the performance characteristics of TSN network devices. For this purpose, TSNPerf needs to be able to precisely send critical packets into the network to test the devices\u0026rsquo; time synchronization performance and traffic shaping capabilities. However, the send() function provided by the Linux operating system can only achieve microsecond-level packet sending precision, which is insufficient for TSNPerf\u0026rsquo;s high-precision requirements.\nTo visually demonstrate the packet sending precision limitations of the send() function, we conducted a test. In this test, we used the send() function to continuously send 10,000 packets at a set interval of 1 millisecond. We then recorded the actual time intervals between each pair of adjacent packets and calculated the deviation from the expected 1 millisecond interval. The results showed that even without any background processes/traffic interference, the intervals between adjacent packets still reached up to approximately 14 microseconds. We next analyze the cause of this phenomenon.\nAs shown in the diagram below, at time \\( t_0 \\)\r, the program calls the send() function to send a packet to the network, but in reality, the packet is not sent until time \\( t_1 \\)\r. This is because the operating system\u0026rsquo;s network stack requires time to process the packet. We refer to the delay from \\( t_1-t_0 \\)\ras the network stack\u0026rsquo;s processing delay, which is typically on the order of microseconds.\nSolution\r#\rIntel\u0026rsquo;s I210 / I225 / I226 network cards provide the LaunchTime feature, which allows precise control over the timing of packets leaving the network interface (theoretical precision at the 32-nanosecond level).\nUsing LaunchTime, we can enhance the precision of packet transmission. As shown in the diagram above, for a packet that needs to be sent at time \\( t_0 \\)\r, we reserve a period for the network stack\u0026rsquo;s processing and call the send() function ahead of time at \\( t_2 \\)\rto ensure the packet is waiting in the network card\u0026rsquo;s output queue before \\( t_0 \\)\r. LaunchTime then opens the output queue gate at \\( t_0 \\)\rto send the packet.\nPerformance Validation\r#\rSimilarly, with the LaunchTime feature enabled, we continuously sent 10,000 packets at a set interval of 1 millisecond and recorded the actual intervals between each pair of packets along with the deviation from 1 millisecond. As shown in the results below, the sending time errors of all packets did not exceed 100 nanoseconds, meeting TSNPerf\u0026rsquo;s precision requirements for packet transmission.\n"},{"id":2,"href":"/docs/switch/require/","title":"Preparation Checklist","section":"ZIGGO Switch","content":"\rPreparation Checklist\r#\rSoftware Environment Checklist\r#\rVivado Development Environment\r#\rVivado is the hardware development program for development boards.\nOfficial download address for Vivado software by Xilinx: http://china.xilinx.com/support/download.html\nOur development team uses the 2020.1 version of Vivado, and we recommend that ZIGGO project users also use the same version to avoid unnecessary trouble.\nFor the specific installation process, refer to ZYNQ Application Tutorial Chapter 3 Vivado Development Environment for installation.\nMobaXterm\r#\rMobaXterm is a serial connection tool, which we introduced in the chapter \u0026ldquo;Launch the Board and log in\u0026rdquo; in hardware_build.md.\nOfficial download address for MobaXterm: MobaXterm Xserver with SSH, telnet, RDP, VNC and X11 - Download (mobatek.net)\nHardware Preparation Checklist\r#\rAlinx7021 Development Board\r#\rSD Boot Card\r#\rThe SD boot card contains the operating system, recommended capacity (\\geq) 32GB.\nEssential Cables\r#\rIncludes Ethernet cables, data cables, etc.\nStandard Switch\r#\rIf using a large number of development boards, consider connecting all development boards to a standard switch, then connecting the switch to a PC (via Ethernet) for management and use.\n"},{"id":3,"href":"/docs/switch/system-design/","title":"System Design","section":"ZIGGO Switch","content":"\rSystem Design\r#\rThe CaaS/TSN Switch is developed based on the ZYNQ platform. The diagram below shows the composition of the ZYNQ chip. ZYNQ mainly consists of a Processing System (PS) and Programmable Logic (PL). The PS and PL mainly communicate with each other through the high-performance Advanced eXtensible Interface (AXI), which is more efficient than using FPGA directly as a peripheral. The PS contains an ARM-based processor suitable for running applications, drivers, and operating systems, while the PL contains FPGA suitable for running low-level hardware logic with high real-time performance requirements.\nFor the Switch, the PL part mainly implements:\nthe real-time clock module and timestamp cache module in time synchronization; the basic forwarding function and traffic control function of the switch. The PS part mainly implements:\nthe state machine logic related to time synchronization; the configuration program of the switch. Time Synchronization\r#\rPlease refer to the Wikipedia for basic knowledge about clock synchronization .\nThe TSN switch complies with IEEE 802.1AS standards. It synchronize neighbor clocks in a decentralized manner and achieves clock accuracy in the sub-microsecond range, making it suitable for measurement and control systems. For each pair of connected devices, their time synchronization state machine will measure link delay and update their local RTC (real-time clock) according to Master clock.\nThe overall design of the time synchronization module is shown in the diagram below. The PS mainly consists of time synchronization state machine modules, which mainly run the state machine logic defined in the 802.1AS standard. The PL mainly consists of real-time clock modules and timestamp cache modules, which are mainly responsible for running the real-time clock and recording the time when data frames enter and exit the switch port.\nAfter the data frame enters the PL from the input port of the switch, the timestamp cache module will record and cache the timestamp when the data frame enters the hardware. The switch\u0026rsquo;s exchange module will determine whether the data frame is related to time synchronization. Time synchronization data frames will be forwarded from the PL to the PS for processing through the Direct Memory Access (DMA) channel. In the PS, the time synchronization state machine module needs to obtain the real-time clock information of the underlying PL and the hardware timestamps corresponding to different data frames through the AXI4-Lite interface. When the switch needs to send time synchronization-related data frames, the PS is responsible for encapsulating the sent data frames and then forwarding them to the PL for processing through the DMA channel. Since time synchronization also needs to record the sending time of messages such as Sync and Pdelay_Req, the timestamp cache module will still cache the sending timestamp before the data frame is sent from the output port, so that the PS can use it later.\nSwitch Fabric \u0026amp; Gate Control\r#\rThe overall design of the switch fabric and gate control module is shown in the diagram below. The PS part mainly includes a configuration module, which is used for software-level configuration of the switch\u0026rsquo;s Gate Control List (GCL) and MAC forwarding table; the PL part mainly consists of the switch fabric and the gate control module, which are responsible for port forwarding and real-time control of traffic.\nAfter the data frame enters the PL from the input port, both ordinary traffic and key traffic will enter the switch fabric. The switch fabric will look up the corresponding output port based on the destination MAC address in the data frame, and then put the data frame into the priority queue in the gate module. The gate control module will control the gate state of each priority queue according to the pre-configured GCL, and then forward the data frame from the corresponding port. In the above process, the gate control module needs to obtain the globally synchronized time from the time synchronization module. The configuration module in the PS part mainly modifies the registers related to GCL (tsn_drivers\\gcl.c) and MAC forwarding table (tsn_drivers\\switch_rules.c) through the UIO driver and AXI4-Lite interface, thereby controlling the parameters in the switch fabric and gate module in the PL part.\nSource Code Description\r#\rTime Sync State Machine\r#\rThe main function for time synchronization is located in time_sync_main_loop.c. It is implemented based on IEEE 802.1AS 2020 standard. The following table introduces the relationship between the state machine code in the code and the state machine in the standard.\nCode Filename (.c/.h) Corresponding Section in 802.1AS-2020 site_sync_sync_sm 10.2.7 SiteSyncSync port_sync_sync_receive_sm 10.2.8 PortSyncSyncReceive clock_master_sync_send_sm 10.2.9 ClockMasterSyncSend clock_master_sync_receive_sm 10.2.11 ClockMasterSyncReceive port_sync_sync_send_sm 10.2.12 PortSyncSyncSend clock_slave_sync_sm 10.2.13 ClockSlaveSync port_announce_information_sm 10.3.12 PortAnnounceInformation port_state_selection_sm 10.3.13 PortStateSelection port_announce_information_ext_sm 10.3.14 PortAnnounceInformationExt port_announce_transmit_sm 10.3.16 PortAnnounceTransmit md_sync_receive_sm 11.2.14 MDSyncReceiveSM md_sync_send_sm 11.2.15 MDSyncSendSM md_pdelay_req_sm 11.2.19 MDPdelayReq md_pdelay_resp_sm 11.2.20 MDPdelayResp UIO addresses\r#\rThe UIO driver is mainly used to map logical addresses to physical addresses, thereby controlling the registers of modules such as TSU, RTC, GCL, etc. The driver code is located in the tsn_drivers folder. The correspondence between the register addresses in the software part and the hardware are described in the header files.\nFor example, in the tsn_drivers\\rtc.h file, the address of the RTC module is defined as follows:\n// define RTC address values #define RTC_CTRL 0x00000000 #define RTC_NULL_0x04 0x00000004 #define RTC_NULL_0x08 0x00000008 #define RTC_NULL_0x0C 0x0000000C #define RTC_TIME_SEC_H 0x00000010 #define RTC_TIME_SEC_L 0x00000014 #define RTC_TIME_NSC_H 0x00000018 #define RTC_TIME_NSC_L 0x0000001C #define RTC_PERIOD_H 0x00000020 #define RTC_PERIOD_L 0x00000024 #define RTC_ADJPER_H 0x00000028 #define RTC_ADJPER_L 0x0000002C #define RTC_ADJNUM 0x00000030 #define RTC_OFFSET_S_H 0x00000034 #define RTC_OFFSET_S_L 0x00000038 #define RTC_OFFSET_NS 0x0000003C MAC Forwarding\r#\rThe MAC address forwarding table configured in the switch_rules.c/h file actually operates the registers in swtich datapath and gate control list. These registers are in pairs, the first register represents the network byte order of the last 32 bits of the destination MAC address, and the second register represents the forwarding port.\nThe CaaS switch has 7 ports, of which 4 are external physical ports, and 3 are virtual ports inside the switch connecting PL and PS. The 3 internal virtual ports specifically include:\nTime Synchronization DMA: Used for transferring time synchronization data frames between PS and PL. PS ETH: Used for communication between PL\u0026rsquo;s physical network port and PS\u0026rsquo;s operating system (for example, using an SSH client to remotely log in and access the switch\u0026rsquo;s PS). PLC DMA: Used in CaaS to transfer input and output of control tasks. The following interface is provided to control the switch fabric\u0026rsquo;s forwarding rule:\nint push_switch_rule(char *mac_addr, int output_port) { /* Push a switch rule to the rule table mac_addr: 6 byte destination mac address. output_port: 0 -\u0026gt; to Port 0 1 -\u0026gt; to Port 1 2 -\u0026gt; to Port 2 3 -\u0026gt; to Port 3 4 -\u0026gt; to PLC DMA The switch rule for PTP frames are fixed in hardware, no need to specify explicitly. */ ... } Gate Control\r#\rTSN critical traffic data frames adopt the standard VLAN data frame format, and the priority is defined in the VLAN tag. VLAN refers to Virtual Local Area Network technology, defined in the 802.1Q standard. As shown in the figure below, the standard VLAN data frame contains a 4-byte VLAN tag, the TPID field represents the VLAN data frame type (0x8100), and the priority of critical traffic is defined in the PRI field, with a value range of [0, 7], corresponding to 8 priority queues. The output queue module identifies the priority of data frames based on the VLAN field in the critical data frame, and then places the data frame in the corresponding output port\u0026rsquo;s priority queue waiting for transmission.\nNotice: According to the IEEE 802.1Qbv standard, priority = 1 maps to priority 0; priority = 0 maps to priority 1; other priorities map to the corresponding queues. Therefore, normal traffic will default to entering priority queue 1 of the corresponding port.\nThe CaaS Switch\u0026rsquo;s gate control module implements the Time Aware Shaper defined by 802.1Qbv, which is used to execute hardware gate scheduling according to the TSN schedule table configured by PS, to ensure the deterministic transmission of critical traffic. Our GCL is represented by 9 bits, with the highest bit representing whether the Guardband is enabled, and the remaining 8 bits representing the gate switches. For example, 9'1_0000_0001 means that the Guardband is enabled, and only the gate switch of the first queue is open.\nNotice that the time unit of GCL in hardware is 2^11 ns, while the time unit in the configuration file issued is 2^14 ns.\nThe following interfaces in gcl.c/h are provided to get/set the hardware GCL (set the gate state and time interval seperately):\n/** * @description: This function is used to get gcl values of the port [portNumber]. * @param {uint16_t} portNumber port\u0026#39;s number. * @return {*} 0 by default. */ int get_gcl(uint16_t portNumber) { ... } /** * @description: This function is used to set GCL\u0026#39;s value, set port [portNumber] \u0026#39;s GCL[gcl_id] to [value]. * @param {uint16_t} portNumber port number, start from 0. * @param {uint16_t} gcl_id GCL index. * @param {uint16_t} value the GCL value to set. * @return {*} 0 by default. */ int set_gcl(uint16_t portNumber, uint16_t gcl_id, uint16_t value) { ... } /** * @description: This function is used to get all GCL time intervals of port [portNumber]. Consider we get time interval is x, the real time interval is (x * 2^8 * 8) nanoseconds. * @param {uint16_t} portNumber port number, start from 0. * @return {*} 0 by default. */ int get_gcl_time_interval(uint16_t portNumber) { ... } /** * @description: This function is used to set GCL\u0026#39;s time interval, set port [portNumber] \u0026#39;s GCL time interval[gcl_id] to [value]. * @param {uint16_t} portNumber port number, start from 0. * @param {uint16_t} gcl_id GCL index. * @param {uint16_t} value the GCL time interval x to set. The real time interval is (x * 2^8 * 8) nanoseconds. * @return {*} 0 by default. */ int set_gcl_time_interval(uint16_t portNumber, uint16_t gcl_id, uint16_t value) { ... } "},{"id":4,"href":"/docs/switch/hardware-build/","title":"Hardware Build","section":"ZIGGO Switch","content":"\rHardware Build\r#\rThis repo contains pre-build hardware \u0026amp; system rootfs to boot the Zynq AX7021 FPGA board from SD card.\nFile downloading\r#\rDownload the following file from this public link:\nBOOT.BIN boot.scr image.ub rootfs.tar.gz SD card partition\r#\rIn order to boot the CaaS Switch, you are supposed to have a micro SD card with \u0026gt;32GiB storage. Then use:\nsudo apt-get install gparted sudo gparted Parition it into two partition below\nBOOT: store boot files from petalinux\nFree space preceding (MiB): 4\nNew size (MiB): 500\nFile system: fat32\nLabel: BOOT\nROOTFS: store debian system rootfs\nFree space preceding (MiB): 0\nFree space following (MiB): 0\nFile system: ext4\nLabel: ROOTFS\nCopy files into SD card\r#\rMound SD card:\nsudo mount /dev/sda1 /media/alinx/BOOT/ sudo mount /dev/sda2 /media/alinx/ROOTFS/ Remove original files:\nsudo rm -rf /media/alinx/BOOT/* /media/alinx/ROOTFS/* Copy files:\nsudo cp BOOT.BIN boot.scr image.ub /media/alinx/BOOT sudo tar -zxvf rootfs.tar.gz -C /media/alinx/ROOTFS sudo cp -r ~/init_os.sh /media/alinx/ROOTFS/home/root/init_os.sh sync sudo chown root:root /media/alinx/ROOTFS sudo chmod 755 /media/alinx/ROOTFS Launch the switch\r#\r1. Launch the Board\r#\rPlug the SD card into FPGA board, turn the switch to SD card boot mode.\n2. Initialize PS\r#\rPlug in SD card, setup AX7021 board to boot on SD, power on.\nConnect a PC to the UART port of the board. We recommend using MobaXterm to connect the serial. Set up the Speed to 115200, Flow Control to None.\nThe default username and password are as follows:\nusername: \u0026#34;root\u0026#34; password: \u0026#34;root\u0026#34; Execute the initilization script to set up the linux environment.\nsh init_os.sh You can freely configure the host name, IP address, and MAC address, etc with the script, and can modify the script if needed.\n3. Connect to Internet\r#\rConnect the PC\u0026rsquo;s network port to the device\u0026rsquo;s PS network port (ETH0).\nSet up PC\u0026rsquo;s corresponding port to be in the same subnet with the device (i.e., 192.168.137.x).\nAfterwards, you can connect to the device through ssh and copy any Software files needed.\n4. Run the Software\r#\rPlease refer to the software part of this repo for further instructions.\n"},{"id":5,"href":"/docs/switch/software-build/","title":"Software Build","section":"ZIGGO Switch","content":"\rSoftware Build\r#\rThis repo contains source code to enable CaaS Switches\u0026rsquo; time synchronization logic and set up TSN GCL (gate control list), switch forwarding rules (including to dual-DMA).\nBuild\r#\rmkdir build cd build cmake .. make After successfully build, there should be two executables: \u0026ldquo;time_sync_app\u0026rdquo; \u0026amp; \u0026ldquo;switch_config\u0026rdquo;\nConfig\r#\rThe \u0026ldquo;config\u0026rdquo; directory contains topology \u0026amp; TSN/CaaS schedule results.\nThis document takes the following topology as an example to give example configurations:\n***-config.json: Mainly describes the network\u0026rsquo;s topology, including the type of each node (device or switch), MAC address, PTP port status, and other node information, topology information, and MAC forwarding table. Example and explanation are as follows (note that the comments in the file are just for explanation, do not have such comments in actual use):\n{ \u0026#34;nodes\u0026#34;: [ // Used to describe the information of each node in the network { \u0026#34;id\u0026#34;: 10, // Node ID, corresponding to \u0026#34;src\u0026#34; and \u0026#34;dst\u0026#34; below \u0026#34;type\u0026#34;: \u0026#34;switch\u0026#34;, // Node type, divided into \u0026#34;switch\u0026#34; and \u0026#34;device\u0026#34; \u0026#34;mac\u0026#34;: \u0026#34;00:0a:35:00:00:10\u0026#34;, // Node\u0026#39;s physical MAC address \u0026#34;ptp_ports\u0026#34;: [ 1, 0, 3, 0, 3 ] // Node\u0026#39;s PTP port status // The quintuple represents the clock status of [local, ETH1, ETH2, ETH3, ETH4] // Number meaning: (0: MASTER, 1: SLAVE, 2: PASSIVE, 3: DISABLED) // If local is 1, it means that the node is the master clock node; // If local is 0, it means that the node is the slave clock node. }, { \u0026#34;id\u0026#34;: 14, \u0026#34;type\u0026#34;: \u0026#34;device\u0026#34;, \u0026#34;mac\u0026#34;: \u0026#34;00:0a:35:00:00:14\u0026#34; }, { \u0026#34;id\u0026#34;: 15, \u0026#34;type\u0026#34;: \u0026#34;device\u0026#34;, \u0026#34;mac\u0026#34;: \u0026#34;00:0a:35:00:00:15\u0026#34; } ], \u0026#34;links\u0026#34;: [ // Topology information, composed of each link, each link is a directed edge { \u0026#34;id\u0026#34;: 0, // link ID \u0026#34;src\u0026#34;: 14, // Source node ID of the link \u0026#34;src_port\u0026#34;: 0, // Port number of the source node // port 0,1,2,3 correspond to ETH1,2,3,4 in reality \u0026#34;dst\u0026#34;: 10, // Destination node ID of the link \u0026#34;dst_port\u0026#34;: 0 // Port number of the destination node }, { \u0026#34;id\u0026#34;: 1, \u0026#34;src\u0026#34;: 10, \u0026#34;src_port\u0026#34;: 0, \u0026#34;dst\u0026#34;: 14, \u0026#34;dst_port\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: 2, \u0026#34;src\u0026#34;: 10, \u0026#34;src_port\u0026#34;: 2, \u0026#34;dst\u0026#34;: 15, \u0026#34;dst_port\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: 3, \u0026#34;src\u0026#34;: 15, \u0026#34;src_port\u0026#34;: 0, \u0026#34;dst\u0026#34;: 10, \u0026#34;dst_port\u0026#34;: 2 } ], \u0026#34;fwd\u0026#34;: [ // Forwarding table, which can be generated by the scheduling algorithm in CNC // In the forwarding table where you send to yourself, the port is 4 (caas) / 5 (PS ETH for new hardware) { \u0026#34;src\u0026#34;: 10, // Current node ID \u0026#34;dst\u0026#34;: 14, // Output port number \u0026#34;id\u0026#34;: 0, // Entry ID \u0026#34;src_port\u0026#34;: 0 // Destination node ID }, { \u0026#34;src\u0026#34;: 14, \u0026#34;dst\u0026#34;: 10, \u0026#34;id\u0026#34;: 1, \u0026#34;src_port\u0026#34;: 0 }, { \u0026#34;src\u0026#34;: 10, \u0026#34;dst\u0026#34;: 15, \u0026#34;id\u0026#34;: 2, \u0026#34;src_port\u0026#34;: 2 }, { \u0026#34;src\u0026#34;: 15, \u0026#34;dst\u0026#34;: 10, \u0026#34;id\u0026#34;: 3, \u0026#34;src_port\u0026#34;: 0 } ] } If the master clock selection algorithm is used, only the configuration of nodes is different, and the rest are the same. The newly added externalPortConfigurationEnabled and system_identity fields are optional items, as shown in the example below:\n{ \u0026#34;nodes\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;switch\u0026#34;, \u0026#34;id\u0026#34;: 0, \u0026#34;mac\u0026#34;: \u0026#34;00:00:00:00:02:01\u0026#34;, \u0026#34;ptp_ports\u0026#34;: [0,0,0,0,0], \u0026#34;externalPortConfigurationEnabled\u0026#34;: 1, // 1: Manually configure the master-slave relationship, 0: Configure the master-slave relationship through the master clock selection algorithm, if this item is not written, the default is 0, that is, configure the master-slave relationship through the master clock selection \u0026#34;system_identity\u0026#34;: { // Clock node\u0026#39;s clock parameters, used for comparison in the master clock selection algorithm, if this item is not written, the default is the configuration written below \u0026#34;priority1\u0026#34;: 254, // First priority \u0026#34;clockClass\u0026#34;: 248, // Clock level \u0026#34;clockAccuracy\u0026#34;: 254, // Clock accuracy \u0026#34;offsetScaledLogVariance\u0026#34;: 17258, // Clock variance \u0026#34;priority2\u0026#34;: 247, // Second priority \u0026#34;clock_identity\u0026#34;: [0,0,0,0,0,0,0,0] // Clock identifier, different clocks should have different parameters } } ], \u0026#34;links\u0026#34;: [ ], \u0026#34;fwd\u0026#34;: [ ] } ***-schedule.json: schedule file, contains each links\u0026rsquo; schedule time interval \u0026amp; each CaaS switch\u0026rsquo;s computation time interval.\n[ {// All switches need to be listed to facilitate software recognition of configuration information \u0026#34;type\u0026#34;: \u0026#34;switch\u0026#34;, // Node type, divided into \u0026#34;switch\u0026#34; and \u0026#34;device\u0026#34; \u0026#34;id\u0026#34;: 10, // Node ID, corresponding to \u0026#34;src\u0026#34; and \u0026#34;dst\u0026#34; below \u0026#34;mac\u0026#34;: \u0026#34;00:0a:35:00:00:10\u0026#34;, // Node\u0026#39;s physical MAC address \u0026#34;schedule\u0026#34;: [ ] // Can be empty, not used }, { \u0026#34;type\u0026#34;: \u0026#34;link\u0026#34;, // Type is link, used to describe scheduling information \u0026#34;from\u0026#34;: 14, // Source node ID of the link \u0026#34;to\u0026#34;: 10, // Destination node ID of the link \u0026#34;from_port\u0026#34;: 0, // Output port number \u0026#34;id\u0026#34;: 3, \u0026#34;schedule\u0026#34;: [ // Scheduling information { \u0026#34;period\u0026#34;: 2048, // Scheduling cycle \u0026#34;start\u0026#34;: 0, // Start time relative to the entire cycle \u0026#34;end\u0026#34;: 5, // End time relative to the entire cycle \u0026#34;job_id\u0026#34;: 0, // Job ID in CaaS, if not needed, it can be omitted \u0026#34;flow_id\u0026#34;: 0 // Data stream ID } ] }, { \u0026#34;type\u0026#34;: \u0026#34;link\u0026#34;, \u0026#34;from\u0026#34;: 10, \u0026#34;to\u0026#34;: 15, \u0026#34;from_port\u0026#34;: 2, \u0026#34;id\u0026#34;: 0, \u0026#34;schedule\u0026#34;: [ { \u0026#34;period\u0026#34;: 2048, \u0026#34;start\u0026#34;: 1, \u0026#34;end\u0026#34;: 6, \u0026#34;job_id\u0026#34;: 0, \u0026#34;flow_id\u0026#34;: 0, \u0026#34;pkt_size\u0026#34;: 1500 // Packet length, if not written, the default is 1500B, this item only exists on the path from Device to Switch } ] } ] Run\r#\rCopy topology \u0026amp; schedule file to build dir: cp [topology name]-config.json build/config.json cp [topology name]-schedule.json build/schedule.json Start time synchronization and initialize GCL and MAC forwarding table according to the configuration (it is recommended to run the time synchronization program on a core (with taskset -c 1 command) to prevent kernel errors and crashes due to time synchronization): taskset -c 1 ./time_sync The log output level is categorized into three types: WARN, INFO, and TRACE. The default log output level is TRACE (the most comprehensive output information, including DEBUG logs). The log output level can be set with the -l parameter: taskset -c 1 ./time_sync -l w # WARN level taskset -c 1 ./time_sync -l i # INFO level taskset -c 1 ./time_sync -l t # TRACE level Notice that the time sync logic is supposed to run indefinitely as the node should sync to its neighbors again and again.\nUpdate GCL \u0026amp; switch forwarding rules: ./switch_config "},{"id":6,"href":"/docs/tsnperf/","title":"ZIGGO TSNPerf","section":"Docs","content":" ZIGGO TSNPerf: A flexible, comprehensive and user-friendly TSN evaluation toolkit.\r#\rTable of Contents\r#\rZIGGO TSNPerf: A flexible, comprehensive and user-friendly TSN evaluation toolkit. Table of Contents Introduction Features Getting Started Test Case License and Citation Contributing Acknowledgement Introduction\r#\rZIGGO is a flexible, standard-compliant, and control-function-virtualized TSN switch platform ready for industrial control, automotive electronics, and other time-sensitive applications.\nThis is the document for the ZIGGO TSNPerf. ZIGGO TSNPerf is a flexible, comprehensive and user-friendly TSN evaluation toolkit. It provides protocol compliance assesment and network performance evaluation. The following figure illustrates the similarities and differences between ZIGGO TSNPerf and iPerf3.\nFeatures\r#\rZIGGO TSNPerf provides protocol compliance assesment and network performance evaluation. It is an all-round hardware-software integrated solution, including\nTime synchronization test: Accurate timestamp (up to 8ns), time synchronization accuracy and protocol consistency analysis\nTraffic shaping test: (1) Precise replay and recording of critical traffic, and (2) GCL capability, bandwidth guarantee and GCL accuracy testing\nNetwork Configuration Testing: (1) Qcc configuration capability and data model consistency analysis, and (2) TSN traffic automatic scheduling and results verification\nGetting Started\r#\rPlease refer to TSNPerf documents to get prepared.\nTest Case\r#\rWe exploit ZIGGO TSNPerf to conduct a comprehensive test on a Brand A TSN switch. The following figures show the test results for GCL capability, bandwidth guarantee, and GCL accuracy for the Brand A switch. The results reveal that the Brand A TSN switch provides high-priority resource reservation (i.e., gating capability) and bandwidth guarantees for critical traffic, but its GCL accuracy is low, failing to meet the requirements of the IEEE 802.1Qbv protocol.\nFor more details of this test case, please refer to the test report.\nLicense and Citation\r#\rZIGGO is released under a MIT license.\nPlease consider citing our papers if the project helps your research with the following BibTex:\n@inproceedings{caas, author={Yang, Zheng and Zhao, Yi and Dang, Fan and He, Xiaowu and Wu, Jiahang and Cao, Hao and Wang, Zeyu and Liu, Yunhao}, booktitle={IEEE INFOCOM 2023 - IEEE Conference on Computer Communications}, title={CaaS: Enabling Control-as-a-Service for Time-Sensitive Networking}, year={2023}, pages={1-10}, doi={10.1109/INFOCOM53939.2023.10228980} } @inproceedings{etsn, author={Zhao, Yi and Yang, Zheng and He, Xiaowu and Wu, Jiahang and Cao, Hao and Dong, Liang and Dang, Fan and Liu, Yunhao}, booktitle={IEEE ICDCS 2022 - IEEE International Conference on Distributed Computing Systems}, title={E-TSN: Enabling Event-triggered Critical Traffic in Time-Sensitive Networking for Industrial Applications}, year={2022}, volume={}, number={}, pages={691-701}, doi={10.1109/ICDCS54860.2022.00072}} Contributing\r#\rPlease see the guide for information on how to ask for help or contribute to the development of ZIGGO!\nThe development team will only answer questions on github issues and reject other forms of questions.\nAcknowledgement\r#\rThis project references parts of the Intel iotg repository.\n"},{"id":7,"href":"/docs/switch/contributing/","title":"How to contribute","section":"ZIGGO Switch","content":"\rHow to contribute\r#\rReporting a bug\r#\rFile bugs in the Github Issue Tracker. Please follow these guidelines:\nSearch existing issues first, make sure yours hasn\u0026rsquo;t already been reported. Consider enabling debug mode so that you can provide as much details as possible when reporting the issue. Stay on topic, but describe the issue in detail so that others can reproduce it. Provide a screenshot if possible. A screenshot showing the problem is often more useful than a paragraph describing it. The development team will only answer questions on github issues and reject other forms of questions.\nContributing to ZIGGO\u0026rsquo;s code\r#\rIf you want to start contributing to the project\u0026rsquo;s code, please follow these guidelines before creating a pull request:\nThe top post of the pull request should contain a full, self-contained explanation of the feature: what it does, how it does it, with examples of usage and screenshots. Also explain why you want to add this - what problem does it solve. Do not simply add a text Implement feature #4345 , because the information there will most likely be outdated or confusing (multiple discussions and opinions). The pull request needs to be self-contained. Bug fixes are always welcome. A good way to easily start contributing is to pick and work on a good first issue. We try to make these issues as clear as possible and provide basic info on how the code should be changed, and if something is unclear feel free to ask for more information on the issue. Before adding a new feature, ask about it in the Github Issue Tracker , or check if existing discussions exist to make sure the new functionality is desired. Pull requests that make many changes using an automated tool, like for spell fixing, styling, etc. will not be accepted. Pull requests that address multiple issues will most likely stall and eventually be closed. This is because we might be fine with one of the changes but not with others and untangling that kind of pull request is too much hassle both for maintainers and the person who submitted it. So most of the time someone gives up and the PR gets closed. So please keep the pull request focused on one issue. Do not mark your reviewer\u0026rsquo;s comments as \u0026ldquo;resolved\u0026rdquo;. If you do that, the comments will be hidden and the reviewer will not know what are the pending issues in the pull request. Only the reviewer should resolve the comments. "},{"id":8,"href":"/docs/switch/","title":"ZIGGO Switch","section":"Docs","content":" ZIGGO CaaS Switch: A flexible, standard-compliant, and control-function-virtualized TSN switch platform\r#\rTable of Contents\r#\rZIGGO CaaS Switch: A flexible, standard-compliant, and control-function-virtualized TSN switch platform Table of Contents Introduction ZIGGO Open Platform Demo Features Read before start Getting Started System Design Demo APP Tutorial License and Citation TODO List Contributing Introduction\r#\rZIGGO is a flexible, standard-compliant, and control-function-virtualized TSN switch platform ready for industrial control, automotive electronics, and other time-sensitive applications.\nThis is the document for the ZIGGO CaaS Switch. (We also offer ZIGGO-Device that comply with the IEEE 802.1 TSN standard.)\nZIGGO Open Platform\r#\rThe construction of the ZIGGO Open Platform consists of three levels: network device, management tools, and a Demo App. More details in ZIGGO-Device.\nDemo\r#\rWe provide a demonstration video of the TSN switch. It demonstrates the superior performance of the ZIGGO-CaaS-Switch compared to the normal switch.\nThe left side of the picture is the ZYNQ development board we use, and the right side is the TSN display board we built.\nClick the pic to watch the video! Or just click here.\nFeatures\r#\rZIGGO supports the simultaneous transmission of both Information Technology (IT) and Operation Technology (OT) data traffic with QoS guarantee.\nZIGGO complies with IEEE standards 802.1AS, Qav, Qbv, and Qcc.\nZIGGO provides Real-time and Deterministic Ethernet transport\nZIGGO achieve Zero Packet Loss , Microsecond-level Latency with Nanosecond-level Jitter Gate Ability.\nZIGGO guarantee Gigabit Throughput.\nZIGGO provide gate accuracy applicable to All Ethernet Frame Sizes.\nRead before start\r#\rGetting started with ZIGGO-CaaS-Switch/ZIGGO-Device is a pretty hard task. Users/developers need to have sufficient basic knowledge and be prepare to for a long periond of learning and debugging.\nPlease refer to basic_knowledge.md to check if you have ability to use ZIGGO competently.\nGetting Started\r#\rPlease refer to required.md to get prepared.\nPlease refer to hardware-build.md for the build hardware for ZIGGO Evaluation Toolkit and software-build.md to run time synchronization logic and set up TSN GCL .\nSystem Design\r#\rZIGGO is implemented on ZYNQ-7000 SoC and exploits ZYNQ\u0026rsquo;s both hardware and software programmability.\nWe also provide more in-depth documentation explaining specific design principles for ZIGGO CaaS Switch.\nDemo APP Tutorial\r#\rWe also provide a testbed build document(in ZIGGO Device) that allows you to build a real-time Ethernet system using the ZIGGO swtich and ZIGGO Device.\nThrough this platform, we can measure the delay and jitter of TSN time-critcial traffic, the switch\u0026rsquo;s gating capability, bandwidth guarantee and gating accuracy.\nReplacing ZIGGO CaaS switches with commercial TSN switches can also test its above capabilities.\nLicense and Citation\r#\rZIGGO is released under a MIT license.\nPlease consider citing our papers if the project helps your research with the following BibTex:\n@inproceedings{caas, author={Yang, Zheng and Zhao, Yi and Dang, Fan and He, Xiaowu and Wu, Jiahang and Cao, Hao and Wang, Zeyu and Liu, Yunhao}, booktitle={IEEE INFOCOM 2023 - IEEE Conference on Computer Communications}, title={CaaS: Enabling Control-as-a-Service for Time-Sensitive Networking}, year={2023}, pages={1-10}, doi={10.1109/INFOCOM53939.2023.10228980} } @inproceedings{etsn, author={Zhao, Yi and Yang, Zheng and He, Xiaowu and Wu, Jiahang and Cao, Hao and Dong, Liang and Dang, Fan and Liu, Yunhao}, booktitle={IEEE ICDCS 2022 - IEEE International Conference on Distributed Computing Systems}, title={E-TSN: Enabling Event-triggered Critical Traffic in Time-Sensitive Networking for Industrial Applications}, year={2022}, volume={}, number={}, pages={691-701}, doi={10.1109/ICDCS54860.2022.00072}} TODO List\r#\rZIGGO CaaS Switch Release\nZIGGO Evaluation Toolkit Release\nZIGGO Evaluation Toolkit Source Code\nTutorial for build a testbed\nTest Case for TSN\nWe will expand each test in the tutorial to multiple test cases to cover different edge cases and comprehensively test the performance of TSN switches.\nSupport Device List At present, we have only tested our own Ziggo switches and are testing other commercial switches (such as Huawei ,H3C and NXP). We expect to maintain a list of test results in the future.\nContributing\r#\rPlease see the guide for information on how to ask for help or contribute to the development of ZIGGO!\nThe development team will only answer questions on github issues and reject other forms of questions.\n"},{"id":9,"href":"/docs/tsnperf/configuration/","title":"TSNPerf User Guide","section":"ZIGGO TSNPerf","content":"\rTSNPerf User Guide\r#\rHardware Preparation\r#\rPrepare two machines, one as the sender (Publisher) and the other as the receiver (Recorder), each equipped with the following hardware requirements:\nIntel processor, 8th generation or above Intel I210 / I225-LM / I225-LM network cards Note: The Publisher should have two network cards installed—one for time synchronization and the other for sending packets. The Recorder only needs one network card, which will handle both time synchronization and data reception.\nSystem Preparation\r#\rInstall the following systems and software dependencies on both the sender and receiver machines:\nInstall Ubuntu 22.04 Install Intel ECI: https://eci.intel.com/docs/3.1/getstarted/requirements.html Install linuxPTP, see the next section Install dependencies: sudo apt-get install libconfig-dev libpcap-dev Before starting the experiment, ensure that the devices to be tested are properly connected to the Publisher and Recorder and that the machines are powered on.\nEnable Time Synchronization\r#\rInstalling linuxPTP\r#\r1. Install the Network Card Driver\r#\rDownload the driver from Intel\u0026rsquo;s website and follow the tutorial in the README file to compile and install the driver.\nUse the following command to check the installation (enp3s0 is the network card name). If installed correctly, you should see the output highlighted in the red box below (indicating that the network card has hardware timestamp capabilities):\nethtool -T enp3s0 2. Install linuxPTP\r#\rInstall linuxPTP with the following commands:\ngit clone http://git.code.sf.net/p/linuxptp/code linuxptp cd linuxptp/ make sudo make install Synchronize the Clocks of Publisher and Recorder\u0026rsquo;s Network Cards\r#\rUse the following command to start time synchronization on the network cards of both the Publisher and Recorder. Replace enp3s0 with your network card name and \u0026lt;configuration\u0026gt;.cfg with a configuration file based on the examples in linuxptp/configs/ and customized to your requirements.\nsudo ptp4l -i enp3s0 -f \u0026lt;configuration\u0026gt;.cfg -m -l 6 --socket_priority 7 Note: If necessary, also start the time synchronization function on the device under test.\nSynchronize Network Card Clocks with the System Clock\r#\rAfter synchronizing the network cards of the Publisher and Recorder, synchronize their clocks with the system clock as well.\nsudo phc2sys -c CLOCK_REALTIME -s enp3s0 -O -0 -m -l 6 Since the Publisher uses separate network cards for time synchronization and packet sending, synchronize the sending network card\u0026rsquo;s clock with the system as well:\nsudo phc2sys -s CLOCK_REALTIME -c enp1s0 -O -0 -m -l 6 Optimize the Network Stack\r#\rBind Critical Traffic to Queue 0\r#\rExecute the following commands on both the Publisher and Recorder to bind critical traffic to Queue 0.\nsudo ethtool --config-ntuple enp1s0 delete 15 sudo ethtool --config-ntuple enp1s0 flow-type ether proto 0xb62c loc 15 action 0 sudo ethtool -X enp1s0 equal 2 Note:\nenp1s0 represents the network card on the Publisher responsible for sending packets or the network card on the Recorder. The 0xb62c in the second line is the ethertype for critical traffic; ensure it matches the ethertype specified in the next section. Bind Queue 0 Interrupts to Isolated Cores and Set Priority\r#\rExecute the following commands on both the Publisher and Recorder.\nBind to Isolated Cores\ncat /proc/interrupts | grep TxRx-0 sudo sh -c \u0026#34;echo 2 \u0026gt; /proc/irq/131/smp_affinity\u0026#34; Set Priority\nps -ae | grep 131 sudo chrt -fp 95 Enable LaunchTime Feature\r#\rEnable the LaunchTime feature on\nthe Publisher:\nsudo tc qdisc add dev enp1s0 handle 8001: parent root mqprio num_tc 4 map 0 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3 queues 1@0 1@1 1@2 1@3 hw 0 sudo tc qdisc replace dev enp1s0 parent 8001:1 etf offload clockid CLOCK_TAI delta 500000 Modify Configuration Files\r#\rModify the configuration file according to your testing needs. Here is an example configuration default.ini:\nmode: 0 tx-mode: 0 verbose: true use-ziggo-analysis: false pcap-filename: \u0026#34;/home/i210/launchtimedemo/captured_10w_1500Byte.pcap\u0026#34; interface: \u0026#34;enp1s0\u0026#34; smac: \u0026#34;00:1b:21:77:ac:ae\u0026#34; dmac: \u0026#34;00:1b:21:76:ae:75\u0026#34; ethertype: 0xb62c socket-priority: 0 vlan-priority: 0 offset: 150000 early-offset: 300000 use-launchtime: true basetime: 1684559640000000100L packet-size: 1500 packets-to-send: 100000 interval: 1000000 use-udp: true sip: \u0026#34;192.168.16.10\u0026#34; dip: \u0026#34;192.168.16.11\u0026#34; sport: 10000 dport: 10000 Launch the Receiving Program on the Publisher\r#\rThe receiving program can use Intel\u0026rsquo;s txrx-tsn in reception mode, paired with use-ziggo-analysis = false, to directly obtain the packet\u0026rsquo;s sending and receiving timestamps. However, conflicts with iperf during background traffic tests have been observed. Consider using tcpdump to capture packets and save high-precision rx timestamps. Tx timestamps can be obtained from the sender\u0026rsquo;s program output for analysis.\nsudo tcpdump -i \u0026lt;network interface\u0026gt; ether proto 0xb62c -j adapter_unsynced --time-stamp-precision=nano -s 0 -tttt -w \u0026lt;path to save pcap file\u0026gt; Launch the Sending Program on the Recorder\r#\rcd /path/to/launchtimedemo make sudo taskset -c 1 chrt -f 92 ./pcap_replay -c ~/launchtimedemo/config.ini "},{"id":10,"href":"/docs/device/basic_knowledge/","title":"List of Basic Knowledge","section":"ZIGGO Device","content":"\rList of Basic Knowledge\r#\rWe reiterate that using or developing ZIGGO-CaaS-Switch or ZIGGO-Device has a high threshold; you must have certain hardware and software knowledge. If you have no previous experience in hardware development, you may need to carefully consider whether you are suitable for this project, as learning these skills is very time-consuming.\nLearning to use the ZIGGO project demands higher requirements than traditional development tools like FPGA, MCU, ARM, etc. Mastering ZIGGO devices is not something that can be achieved overnight.\nIf you wish to use the ZIGGO project, you should at least have the following knowledge:\nHardware Knowledge\r#\rPrinciples of Computer Organization C Language Fundamentals of Digital Circuits Verilog, VHDL languages Good foundation in English reading Software Knowledge\r#\rPrinciples of Computer Organization Computer Networks Computer Operating Systems C, C++ Languages tcl Scripts Good foundation in English reading "},{"id":11,"href":"/docs/device/require/","title":"Preparation Checklist","section":"ZIGGO Device","content":"\rPreparation Checklist\r#\rSoftware Environment Checklist\r#\rVivado Development Environment\r#\rVivado is the hardware development program for development boards.\nOfficial download address for Vivado software by Xilinx: http://china.xilinx.com/support/download.html\nOur development team uses the 2020.1 version of Vivado, and we recommend that ZIGGO project users also use the same version to avoid unnecessary trouble.\nFor the specific installation process, refer to ZYNQ Application Tutorial Chapter 3 Vivado Development Environment for installation.\nMobaXterm\r#\rMobaXterm is a serial connection tool, which we introduced in the chapter \u0026ldquo;Launch the Board and log in\u0026rdquo; in hardware_build.md.\nOfficial download address for MobaXterm: MobaXterm Xserver with SSH, telnet, RDP, VNC and X11 - Download (mobatek.net)\nHardware Preparation Checklist\r#\rAlinx7021 Development Board\r#\rSD Boot Card\r#\rThe SD boot card contains the operating system, recommended capacity (\\geq) 32GB.\nEssential Cables\r#\rIncludes Ethernet cables, data cables, etc.\nStandard Switch\r#\rIf using a large number of development boards, consider connecting all development boards to a standard switch, then connecting the switch to a PC (via Ethernet) for management and use.\n"},{"id":12,"href":"/docs/device/getting-started/","title":"Getting start","section":"ZIGGO Device","content":"\rGetting start\r#\rTable of Content\r#\rGetting start Table of Content Folder Structure Introduction to git branches Building and Starting the TSNPerf Folder Structure\r#\r. ├── docs //documents for ZIGGO ├── figs //figures for docs ├── hardware //hareware code, for PL part(pkt_gen, time sync in FPGA) ├── readme.md //readme for whole project ├── software //software code, for ps part(pkt_gen, time sync) └── testbed-build //code for building testbed Introduction to git branches\r#\rBranch Name Basic Function Packet Resize Online Analyze Offline Analyze main √ √ packet_resize √ √ √ offline_analyze √ √ The branches of TSNPerf submitted this time can be divided into three categories. But the main branch is inconvenient to use in two ways. In order to solve the above two limitations, we have also submitted two patch branches.\nThe main branch contains basic time synchronization and pkt_gen functions, as well as online analysis functions. However, its limitation is that it can only send Ethernet of MTU (1500B) size, and due to the limited performance of the zynq development board, online analysis may cause packet loss. packet_resize branch can send Ethernet frames of any size (64B-1500B). offline_analyse branch can forward the data packets to the PC for offline analysis to avoid packet loss. Note1: When switch to \u0026lsquo;packet_resize\u0026rsquo; branch, you also need to modify the software/config/flow.json\n{\r\u0026#34;job_id\u0026#34;: 0, \u0026#34;flow_id\u0026#34;: 0,\r\u0026#34;src\u0026#34;: 1,\r\u0026#34;dst\u0026#34;: 2,\r\u0026#34;period\u0026#34;: 2048,\r\u0026#34;MD\u0026#34;: 1024,\r\u0026#34;packet_size\u0026#34;: 750 // add this attribute }, Note2: When switch to \u0026lsquo;offline_anaylze\u0026rsquo; branch, you need to link device to anthor PC (linux) by wire in ETH1.\nBuilding and Starting the TSNPerf\r#\rSet up the FPGA board and initialize PS system\nCompile software code, run the time synchronization \u0026amp; pkt _gen_app\n"},{"id":13,"href":"/docs/device/system-design/","title":"System Design","section":"ZIGGO Device","content":"\rSystem Design\r#\rZIGGO is implemented on ZYNQ-7000 SoC and exploits ZYNQ\u0026rsquo;s both hardware and software programmability.\nTable of Content\r#\rSystem Design Table of Content Evaluation Method Test data frame data structure Module Design Correspondence between software and hardware registers Offline Analysis and Design Evaluation Method\r#\rThe ZIGGO Evaluation Toolkit is used to send and receive test data frames for the purpose of ensuring accurate delay calculations.\nTo achieve this accuracy, the toolkit needs to synchronize its time with the TSN switch and record a global hardware timestamp in the test data frames.\nAs shown in the diagram below, in a data flow link with \\( n \\)\rnetwork nodes, Node \\( 1 \\)\rserves as the source node to send test data frames, Node \\( n \\)\racts as the destination node to receive test data frames, and all the intermediate nodes (Node \\( 2 \\)\rto Node \\( n-1 \\)\r) are TSN switches.\nWhen a test data frame is sent from the source node, the hardware records the timestamp \\( t^\u0026#43; \\)\rof when the frame was sent in the data frame. Finally, when the data frame arrives at the destination node, the destination node records the timestamp \\( t^- \\)\rof when the frame entered that node. By calculating \\( t^--t^\u0026#43; \\)\r, we can determine the end-to-end latency of the data frame.\nIn this doc, \\( t^{dir} \\)\ris used to represent the timestamp of data frames entering and leaving the hardware. Here, \u0026ldquo;dir\u0026rdquo; represents the direction of data frames entering or leaving the nodes, with \u0026quot; + \u0026quot; indicating data frames leaving the node and \u0026quot; − \u0026quot; indicating data frames entering the node.\nTest data frame data structure\r#\rIn order to analyze the end-to-end latency of each data frame on complex network topologies, we have established specific guidelines for the content of data segments in the Ethernet frame structure. The structure of time-sensitive networking test data frames is as shown in the following table.\nield Byte Length Description Destination Address 6 Destination node MAC address Source Address 6 Source node MAC address VLAN Tag 4 Divided into four fields: VLAN Data Frame Type (0x8100), Priority, Canonical Format Indicator, and VLAN Number Data Frame Type 2 Used to identify test data frames, set to 0x66ab Reserved Bits 2 \\( t^\u0026#43; \\)\r(TX Timestamp) 8 Timestamp when transmitted from the source node \\( t^- \\)\r(RX Timestamp) 8 Timestamp when received by the destination node Data Stream ID (SEQ_ID) 2 Unique identifier for each data stream Data Frame ID (PKT_ID) 4 Sequence number of data frames within each data stream, starting from 0 Module Design\r#\rThe overall module design for ZIGGO Evaluation Toolkit is depicted in the following diagram. The Time Synchronization module used by the Toolkit shares a design that is nearly identical to the Switch, and the diagram does not provide extensive details on the time synchronization-related modules.\nThe configuration module in the PS section (software/pkt_gen_main.cpp) communicates with the Data Frame Generation module by using the UIO driver and AXI4-Lite interface to send the transmission rules for the test data frames to relevant registers in the Data Frame Generation module (specifically, hardware/IP_repo/pkt_gen_controller_v1.1/pkt_gen_controller_1.1/hdl/pkt_gen_controller_v1_1.v is responsible for configuration, and hardwire/HDL/axi_packet_generator.v is responsible for generating and transmitting the data frames) using the global synchronized time as a reference for timing.\nThe Timestamp Marking module (hardwire/HDL/hw_timestamp/tsu/tsu_axis_tx.v and hardwire/HDL/hw_timestamp/tsu/tsu_axis_rx.v) is located at the send and receive ports of the Ziggo-Evaluation-Toolkit. It is used to record the hardware timestamps of sent and received data frames within the test data frames.\nThe received data frames are ultimately uploaded to the PS section via a DMA channel (in our design, we currently use a time-synchronized DMA channel for transmitting test data frames) for statistical analysis (handled in the process_critical_frame function in software/pkt_gen_control/pkt_gen.c).\nThe maximum frame transmission period (superperiod parameter in pkt_gen_main.cpp) refers to the upper limit on the periodicity for sending data streams from the toolkit. Within this maximum frame transmission period, the Data Frame Generation module allocates a maximum of 32 time slots for all data streams. Each time slot is used to send all the data frames for the corresponding data stream at the specified transmission time.\nAs illustrated in the diagram, the evaluation toolkit sends two types of data streams: Stream 𝐹1 with a transmission period of 2𝑇 and Stream 𝐹2 with a transmission period of 4𝑇. The maximum frame transmission period for the evaluation toolkit is 6𝑇. In this scenario, the Data Frame Generation module sets up 5 time slots within the maximum frame transmission period and sends test data frames in sequential order according to the specified time slots.\nUsers can configure the Ziggo-Evaluation-Toolkit to generate multiple data streams, and the configuration parameters for each data stream are as follows, with clear explanations provided in the comments of the pkt_gen.h header file:\n// pkt_gen_app\\pkt_gen_control\\pkt_gen.h /** * @brief Set the pkt gen slot object * * @param slot_id 0~31, indicate a slot in pkt_gen IP core * IMPORTANT: tx_offset for each slot id should be monotonic increasing * @param seq_id sequence ID that uniquely identify a stream * To further utilize this field, it may be {job_id: 8bit, flow_id: 8bit} * @param pkt_number number of packets in one sent, should be 1 * @param pkt_id_start start of pkt_id * @param pkt_id_update update of next pkt_id * @param tx_offset transmission time inside a period, in ns * @param src_mac 6Byte array * @param dest_mac 6Byte array * @return int */ int set_pkt_gen_slot (int slot_id, uint16_t seq_id, uint16_t pkt_number, uint32_t pkt_id_start, uint32_t pkt_id_update, int64_t tx_offset, uint8_t *src_mac, uint8_t *dest_mac); The Timestamp Marking Module will write the timestamp of the current synchronized clock into the outgoing data frame just before it is transmitted by the MAC controller of the toolkit. When the MAC controller in the PL (Programmable Logic) receives the first bit of data in the frame from the physical link, the Timestamp Marking Module records the timestamp of the current synchronized clock. It subsequently writes this timestamp into the data frame during the packet reception process and hands it over to the statistical analysis module in the PS (Processing System) section for further analysis and processing.\nCorrespondence between software and hardware registers\r#\rThe correspondence in terms of time synchronization is the same as in the Ziggo TSN Switch.\nIn this section, we will primarily focus on the correspondence related to data frame transmission configuration. The software registers\u0026rsquo; addresses can be found in software/pkt_gen_control/pkt_gen.c.\n// define global register address #define GLOBAL_PERIOD_NS 0x00000000 #define GLOBAL_OFFSET_NS 0x00000008 #define SEQ_VALID 0x00000010 #define SEQ_ENABLE_VLAN 0x00000014 #define WRITE_LOCK 0x00000018 // define write lock value #define NOT_WRITING 0x00000001 #define WRITING 0x00000000 // define address pointer for sequences #define SEQ_CONTENT 0x0000001c The hardware registers are located in tsn_device\\IP_repo\\pkt_gen_controller_v1.1\\pkt_gen_controller_1.1\\hdl\\pkt_gen_controller_v1_1_S00_AXI.v.\nif (slv_reg_wren) begin case ( axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] ) 9\u0026#39;h000: for ( byte_index = 0; byte_index \u0026lt;= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 0 slv_reg0[(byte_index*8) +: 8] \u0026lt;= S_AXI_WDATA[(byte_index*8) +: 8]; end 9\u0026#39;h001: for ( byte_index = 0; byte_index \u0026lt;= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 1 slv_reg1[(byte_index*8) +: 8] \u0026lt;= S_AXI_WDATA[(byte_index*8) +: 8]; end 9\u0026#39;h002: for ( byte_index = 0; byte_index \u0026lt;= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 ) if ( S_AXI_WSTRB[byte_index] == 1 ) begin // Respective byte enables are asserted as per write strobes // Slave register 2 slv_reg2[(byte_index*8) +: 8] \u0026lt;= S_AXI_WDATA[(byte_index*8) +: 8]; end ... In this context, the hardware registers with names starting with \u0026ldquo;slv_reg\u0026rdquo; are each 32 bits wide, and their addresses are spaced by 4 bytes. So, for example, if the software-level address is \\( 0x00000018 \\)\r, you need to divide this address by 4, which results in \\( 24/4 = 6 \\)\r. Therefore, this address corresponds to the hardware register \u0026ldquo;slv_reg6\u0026rdquo; in the hardware module. This helps establish the correspondence between software and hardware registers.\nOffline Analysis and Design\r#\rIn the offline_analyze branch of the Toolkit, we perform packet capture and analysis by forwarding packets from the Toolkit to a powerful desktop computer after the timestamps the incoming packets. This method ensures that even at gigabit speeds, no packets are dropped, and there are relatively minor hardware changes.\nOne aspect of the modification is that timestamps are not added to the data frames when they are transmitted from the toolkit. This can be seen in the HDL/trimode_mac/simple_mac_no_shared.v file where the \u0026ldquo;tsu_axis_tx\u0026rdquo; section is commented out.\nAnother aspect is the modification of the \u0026ldquo;frame_type\u0026rdquo; to change the direction of data frames. Previously, both PTP frames and test data frames were uploaded to the PS section via time-synchronized DMA, with IT traffic uploaded to PS_ETH. This split the traffic into two directions (\u0026ldquo;axis_switch_1_2\u0026rdquo;). Now, it has been split into three directions (\u0026ldquo;axis_switch_1_3\u0026rdquo;). For offline analysis, only PTP frames need to be transferred to the PS, while test data frames need to be separated and sent out from ETH2. This requires a finer-grained separation of traffic.\n// separate IT frames, ptp frames and critical frames axis_switch_1_3 axis_switch_1_3_inst ( .aclk(rx_fifo_clock), // input wire aclk .aresetn(rx_fifo_resetn), // input wire aresetn .s_axis_tvalid(rx_axis_fifo_tvalid_8), // input wire [0 : 0] s_axis_tvalid .s_axis_tready(rx_axis_fifo_tready_8), // output wire [0 : 0] s_axis_tready .s_axis_tdata(rx_axis_fifo_tdata_8), // input wire [7 : 0] s_axis_tdata .s_axis_tlast(rx_axis_fifo_tlast_8), // input wire [0 : 0] s_axis_tlast .s_axis_tdest(frame_type), // input wire [1 : 0] s_axis_tdest .m_axis_tvalid({rx_axis_it_fifo_tvalid, rx_axis_ptp_fifo_tvalid, tx_axis_fifo_legacy_tvalid[1]}), // output wire [2 : 0] m_axis_tvalid .m_axis_tready({rx_axis_it_fifo_tready, rx_axis_ptp_fifo_tready, tx_axis_fifo_legacy_tready[1]}), // input wire [2 : 0] m_axis_tready .m_axis_tdata({rx_axis_it_fifo_tdata, rx_axis_ptp_fifo_tdata, tx_axis_fifo_legacy_tdata[1]}), // output wire [23 : 0] m_axis_tdata .m_axis_tlast({rx_axis_it_fifo_tlast, rx_axis_ptp_fifo_tlast, tx_axis_fifo_legacy_tlast[1]}), // output wire [2 : 0] m_axis_tlast .m_axis_tdest(), // output wire [5 : 0] m_axis_tdest .s_decode_err() // output wire [0 : 0] s_decode_err ); The tx_axis_fifo_legacy_tdata[1] indicates sending from ETH2.\n"},{"id":14,"href":"/docs/device/hardware-build/","title":"Hardware Build","section":"ZIGGO Device","content":"\rHardware Build\r#\rBefore Start\r#\rIf you just want to teach the board to run instead of modifying it, and you use the hardware files we provide, you can skip directly to step SD card partition and copy file.\nTable of Content\r#\rHardware Build Before Start Table of Content Install Vivado Vivado project construction Petalinux 1.install ubuntu OS 2.Download PetaLinux related image files in advance 3.Activate the PetaLinux environment 4.Create PetaLinux Project 5.Petalinux Configuration 6. SD card partition and copy file File downloading SD card partition Copy files into SD card Launch the Board and log in 1. Launch the Board 2. Initialize PS 3. Connect to Internet 4. Run the Software Install Vivado\r#\rYou can download Vivado here.\nWe are using Vivado version 2020.1 (note: a unified version is required, otherwise running may cause problems).\nVivado project construction\r#\rclone the git repository for the hardware part. Open Vivado and enter the command cd Porject_Dir in Tcl Console and source ./tsn_device.tcl. After the command is executed, Vivado will automatically open the created project. Here, we will first close Vivado and rename the folder where the project is located to Work_ Dir, so that git can correctly ignore this directory and enter Work_ Dir, double-click the .xpr file to open the project again. Click Generate Bitstream Export the xsa file. In Vivado, File Export Export Hardware. Select Fixed for Platform type. Select include bitstream for Output. Click Finish to export the xsa file.\nExported xsa file path: Work_Dir/tns+tsn_device.xsa\nPetalinux\r#\r1.install ubuntu OS\r#\rThe following compilation processes are all completed within the virtual machine.\nWe recommend using the following configuration:\nVirtual machine version: VMware Workstation 16 Pro\rUbuntu version: ubuntu-16.04.3-desktop-amd64.iso 2.Download PetaLinux related image files in advance\r#\rEnter website: https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/embedded-design-tools/archive.html\nSelect 2020.1 to find PetaLinux Tools sstate-cache artifacts and download sstate_ arm_ 2020.1 and downloads and save the downloads in a specified directory in the virtual machine on January 2021 (the directory for this document is set to/home/alinx/data/)\n​ 3.Activate the PetaLinux environment\r#\rsource /opt/pkg/petalinux/settings.sh ​ Automatically activate the PetaLinux environment every time Terminal is started.\n4.Create PetaLinux Project\r#\rpetalinux-create --type project --template zynq --name \u0026lt;project_name\u0026gt; cd \u0026lt;project_name\u0026gt; 5.Petalinux Configuration\r#\rImport Hardware Configuration petalinux-config --get-hw-description \u0026lt;PATH-TO-XSA Directory\u0026gt; Then you will enter the menuconfig page and configure as follows:\nSubsystem AUTO Hardware Settings\r-\u0026gt; Ethernet Settings -\u0026gt; [*] Randomise MAC address\rImage Packaging Configurations -\u0026gt; Root filesystem type -\u0026gt; [*] EXT4 (SD/eMMC/SATA/USB)\rYocto Settings (Use downloaded image)\r-\u0026gt; Local sstate feeds settings: /home/alinx/data/sstate_arm_2020.1/arm\r-\u0026gt; Add pre-mirror url: file:///home/alinx/data/downloads make Kernel Module ​ make a module named \u0026ldquo;dma proxy\u0026rdquo;:\npetalinux-create -t modules -n dma-proxy --enable ​ replace the dma-proxy folder:\nrm -rf project-spec/meta-user/recipes-modules/* download our dma-proxy (from here) and unzip in project-spec/meta-user/recipes-modules/\nConfiguring the kernel petalinux-config -c kernel Entering the menuconfig page, and do:\nDevice Drivers -\u0026gt; Userspace I/O drivers -\u0026gt; [*] Userspace I/O platform driver with generic IRQ handling -\u0026gt; [*] Userspace platform driver with generic irq and dynamic memory -\u0026gt; [*] Xilinx AI Engine driverDevice Drivers -\u0026gt; Dma Engine Support -\u0026gt; [*] Xilinx DMA Engines -\u0026gt; Network device support -\u0026gt; Ethernet driver support -\u0026gt; [*] Cadence devices -\u0026gt; [*] Cadence MACB/GEM support General setup -\u0026gt; Preemption Model -\u0026gt; (X) No Forced Preemption (Server) Configuring rootfs Edit file project-spec/meta-user/conf/user-rootfsconfig, and add the following configuration:\nCONFIG_sudo CONFIG_sudo-dev CONFIG_dnf CONFIG_packagegroup-core-buildessential CONFIG_packagegroup-core-buildessential-dev CONFIG_packagegroup-self-hosted CONFIG_packagegroup-self-hosted-dev CONFIG_packagegroup-self-hosted-sdk-dev CONFIG_packagegroup-self-hosted-sdk CONFIG_python3 CONFIG_autoconf CONFIG_autoconf-dev CONFIG_automake CONFIG_automake-dev CONFIG_bison CONFIG_bison-dev CONFIG_flex CONFIG_flex-dev CONFIG_make CONFIG_make-dev CONFIG_python CONFIG_libtool CONFIG_libtool-dev CONFIG_sqlite3 CONFIG_cmake CONFIG_util-linux CONFIG_net-tools Save and exit.\nInput:\npetalinux-config -c rootfs Then you will enter the menuconfig page and configure as follows:\nImage Features -\u0026gt; [*] package management -\u0026gt; (http://petalinux.xilinx.com/sswreleases/rel-v2020/feeds/zc702-zynq7/) Package feed url.\ruser packages\r-\u0026gt; SELECT ALL Compile the device tree petalinux-build -c device-tree Modify the device tree The generated device tree is located in components/plnx_workspace/device tree/device tree/pl.dtsi directory, we need to make modifications based on this file to meet some of our peripheral needs. The modified files are stored in the project-spec/meta user/recipes bsp/device tree/files/system-user.dtsi directory.\nNote: Between the //\u0026gt;\u0026gt;\u0026gt; and //\u0026lt;\u0026lt;\u0026lt; is the content added between the comments.\n/include/ \u0026#34;system-conf.dtsi\u0026#34; / { amba_pl: amba_pl { dma_proxy { compatible =\u0026#34;xlnx,dma_proxy\u0026#34;; dmas = \u0026lt;\u0026amp;axi_dma_0 0 \u0026amp;axi_dma_0 1\u0026gt;; dma-names = \u0026#34;dma_proxy_tx\u0026#34;, \u0026#34;dma_proxy_rx\u0026#34;; }; pkt_gen_controller_0: pkt_gen_controller@43c00000 { compatible = \u0026#34;generic-uio\u0026#34;,\u0026#34;uio\u0026#34;; reg = \u0026lt;0x43c00000 0x10000\u0026gt;; }; rtc0: time_sync_uio@43c10000 { compatible = \u0026#34;generic-uio\u0026#34;,\u0026#34;uio\u0026#34;; reg = \u0026lt;0x43c10000 0x10000\u0026gt;; }; }; chosen{ bootargs = \u0026#34;console=ttyPS0,115200 earlyprintk cma=256M uio_pdrv_genirq.of_id=generic-uio root=/dev/mmcblk0p2 rw rootwait\u0026#34;; stdout-path = \u0026#34;serial0:115200n8\u0026#34;; }; }; \u0026amp;gem1 { local-mac-address = [00 00 00 00 02 01]; phy-mode = \u0026#34;gmii\u0026#34;; fixed-link { speed = \u0026lt;1000\u0026gt;; full-duplex; }; }; Complie petalinux-build Pack Here, you need to copy the bitstream file generated by Vivado to the virtual machine. (You can export bitstream file to where you want).\nThen:\ncd images/linux petalinux-package --boot --fsbl zynq_fsbl.elf --fpga \u0026lt;FPGA bitstream path\u0026gt; --u-boot --force After that, you can get 4 key file: BOOT.BIN boot.scr image.ub rootfs.tar.gz\n6. SD card partition and copy file\r#\rFile downloading\r#\rDownload the following file from this public link or from preceding steps:\nBOOT.BIN boot.scr image.ub rootfs.tar.gz SD card partition\r#\rIn order to boot the TSNPerf, you are supposed to have a micro SD card with \u0026gt;32GiB storage. Then use:\nsudo apt-get install gparted sudo gparted Parition it into two partition below\nBOOT: store boot files from petalinux\nFree space preceding (MiB): 4\nNew size (MiB): 500\nFile system: fat32\nLabel: BOOT\nROOTFS: store debian system rootfs\nFree space preceding (MiB): 0\nFree space following (MiB): 0\nFile system: ext4\nLabel: ROOTFS\nCopy files into SD card\r#\rMound SD card:\nsudo mount /dev/sda1 /media/alinx/BOOT/ sudo mount /dev/sda2 /media/alinx/ROOTFS/ Remove original files:\nsudo rm -rf /media/alinx/BOOT/* /media/alinx/ROOTFS/* Copy files:\nsudo cp BOOT.BIN boot.scr image.ub /media/alinx/BOOT sudo tar -zxvf rootfs.tar.gz -C /media/alinx/ROOTFS sudo cp -r ~/init_os.sh /media/alinx/ROOTFS/home/root/init_os.sh sync sudo chown root:root /media/alinx/ROOTFS sudo chmod 755 /media/alinx/ROOTFS Launch the Board and log in\r#\r1. Launch the Board\r#\rPlug the SD card into FPGA board, turn the switch to SD card boot mode.\n2. Initialize PS\r#\rPlug in SD card, setup AX7021 board to boot on SD, power on.\nConnect a PC to the UART port of the board. We recommend using MobaXterm to connect the serial. Set up the Speed to 115200, Flow Control to None.\nThe default username and password are as follows:\nusername: \u0026#34;root\u0026#34; password: \u0026#34;root\u0026#34; Execute the initilization script to set up the linux environment. (hardware/init_os.sh)\nsh init_os.sh You can freely configure the host name, IP address, and MAC address, etc with the script, and can modify the script if needed.\n3. Connect to Internet\r#\rConnect the PC\u0026rsquo;s network port to the device\u0026rsquo;s PS network port (ETH0).\nSet up PC\u0026rsquo;s corresponding port to be in the same subnet with the device (i.e., 192.168.137.x).\nAfterwards, you can connect to the device through ssh and copy any Software files needed.\n4. Run the Software\r#\rPlease refer to the software part of this repo for further instructions.\n"},{"id":15,"href":"/docs/device/software-build/","title":"Software Build","section":"ZIGGO Device","content":"\rSoftware Build\r#\rThis repo contains source code to enable TSN/CaaS TSNPerf\u0026rsquo; time synchronization logic and set up packet generation plan.\nTable of Content\r#\rSoftware Build Table of Content 1. Build 2. Config 3. Run 4. Analyze 4.1 TSNPerf directly analyzes latency and jitter 4.2 Offline analysis of latency and jitter 1. Build\r#\rmkdir build cd build cmake .. make After successfully build, there should be two executables: \u0026ldquo;time_sync\u0026rdquo; \u0026amp; \u0026ldquo;pkt_gen\u0026rdquo;\n2. Config\r#\rThe \u0026ldquo;build\u0026rdquo; directory contains topology \u0026amp; TSN/CaaS schedule results.\nconfig.json: topology file, contains node info (type, mac, ptp ports), link between nodes (with ports), and forwarding table. schedule.json: schedule file, contains each links\u0026rsquo; schedule time interval \u0026amp; each CaaS switch\u0026rsquo;s computation time interval. (Hints: This is similar to a Ziggo Switch)\n3. Run\r#\rStart time syncronization ./time_sync Start device critical packet generation ./pkt_gen 4. Analyze\r#\rThere are two analysis methods for TSNPerf:\nHint: If you want to use offline anaylze, please switch branch to \u0026lsquo;offline_anaylze\u0026rsquo;, and you need to link device to anthor PC(linux) by wire.\nOne method is to directly analyze latency and jitter on the TSNPerf.\nAnother method is to use Device to stamp the received packet and forward it from another port to a powerful desktop computer for packet capture analysis. Even if entering the Device at a gigabit rate, there will be no packet loss. The disadvantage is that a separate program needs to be written offline to analyze the delay and jitter of the packet.\n4.1 TSNPerf directly analyzes latency and jitter\r#\rDuring the operation of the time sync program, after receiving the test data frame, the program will save the delay information of the data frame in the package under the build/packet_log.csv file, save the batch statistics of latency and jitter in the critical directory under the build directory at the same time in the build/critical_log.csv.\nYou can display the content of the header and the last 5 lines using the following command:\ncat critical.log | head -n1 cat critical.log | tail -n5 4.2 Offline analysis of latency and jitter\r#\rIf conducting offline analysis, it is important to note that the hardware used is located at offline_analyze branch. This version will stamp the key data with a receive timestamp and forward it from ETH2. We need to use a PC equipped with a Linux system to capture packets for analysis.\nExample of packet capture command:\nsudo tcpdump -i enx207bd272812b ether src 00:0a:35:00:00:14 -n -B 100000 -w packets.pcapng Enx207bd272812b is the name of the network card, which can be obtained through ifconfig. Src is used to specify that the captured packet comes from a certain MAC address. -B is used to specify the buffer size. If packet loss needs to be set to a larger size, you can check the information output after packet capture to see if Dropped by kernel: is 0. If it is not 0, it indicates that there is packet loss in the kernel. -W specifies the path to save the file.\nCode for analyzing programs is analyze_packet.py\npython .\\analyze_packet.py [capture file path] --step [interval] At the same time, a packet will be generated in the current directory (packet_log.csv and critical_log.csv).\n"},{"id":16,"href":"/docs/device/ziggo_device_manual/","title":"ZIGGO Device Manual","section":"ZIGGO Device","content":"\rZIGGO Device Manual\r#\rThere are two analysis methods for ZIGGO Device:\nHint: If you want to use offline anaylze, please switch branch to \u0026lsquo;offline_anaylze\u0026rsquo;, and you need to link device to anthor PC(linux) by wire.\nOne method is to directly analyze latency and jitter on the ZIGGO Device. The advantage of this method is that it is convenient and fast. We can directly count the latency and jitter of all received data frames on the Device. However, due to the limited processing power of the development board CPU, when analyzing a large number of data packets (such as sending more than 10 1500B data packets at a time with a cycle of 33ms), packet loss may occur;\nAnother method is to use Device to stamp the received packet and forward it from another port to a powerful desktop computer for packet capture analysis. Even if entering the Device at a gigabit rate, there will be no packet loss. The disadvantage is that a separate program needs to be written offline to analyze the delay and jitter of the packet.\nZIGGO Device directly analyzes latency and jitter\r#\rDuring the operation of the time sync program, after receiving the test data frame, the program will save the delay information of the data frame in the package under the build/packet_log.csv file, save the batch statistics of latency and jitter in the critical directory under the build directory at the same time in the build/critical_log.csv.\nExample of packet_log.csv:\nSeq ID, Pkt ID, TX timestamp, RX timestamp, Latency\r0101, 0, 12683587446, 12683613722, 26276\r0101, 1, 12683599662, 12683625970, 26308\r0101, 2, 12683611862, 12683638162, 26300\r0101, 3, 12683624078, 12683650386, 26308\r0101, 4, 12717142039, 12717168273, 26234\r0101, 5, 12717154223, 12717180465, 26242\r0101, 6, 12717166391, 12717192625, 26234\r0101, 7, 12717178575, 12717204825, 26250\r0101, 8, 12750696471, 12750722712, 26241\r0101, 9, 12750708655, 12750734904, 26249 Example of critical_ log.csv, where Latency Variance is the variance of Latency:\nSeq ID, Received Number, Max pkt_id, Min pkt_id, Loss Rate, Latency Mean, Latency Variance\r0101, 1000, 0, 999, 0.000000, 26230, 1199\r0101, 1000, 1000, 1999, 0.000000, 26218, 2811\r0101, 1000, 2000, 2999, 0.000000, 26218, 2808\r0101, 1000, 3000, 3999, 0.000000, 26195, 18331\r0101, 1000, 4000, 4999, 0.000000, 26233, 921\r0101, 1000, 5000, 5999, 0.000000, 26226, 852\r0101, 1000, 6000, 6999, 0.000000, 26226, 5080\r0101, 1000, 7000, 7999, 0.000000, 26250, 105272\r0101, 1000, 8000, 8999, 0.000000, 26204, 7233\r0101, 1000, 9000, 9999, 0.000000, 26205, 7361 You can display the content of the header and the last 5 lines using the following command:\ncat critical.log | head -n1 cat critical.log | tail -n5 Offline analysis of latency and jitter\r#\rIf conducting offline analysis, it is important to note that the hardware used is located at offline_analyze branch. This version will stamp the key data with a receive timestamp and forward it from ETH2. We need to use a PC equipped with a Linux system to capture packets for analysis.\nExample of packet capture command:\nsudo tcpdump -i enx207bd272812b ether src 00:0a:35:00:00:14 -n -B 100000 -w packets.pcapng Enx207bd272812b is the name of the network card, which can be obtained through ifconfig. Src is used to specify that the captured packet comes from a certain MAC address. -B is used to specify the buffer size. If packet loss needs to be set to a larger size, you can check the information output after packet capture to see if Dropped by kernel: is 0. If it is not 0, it indicates that there is packet loss in the kernel. -W specifies the path to save the file.\nCode for analyzing programs is analyze_packet.py\npython .\\analyze_packet.py [capture file path] --step [interval] At the same time, a packet will be generated in the current directory (packet_log.csv and critical_log.csv).\n"},{"id":17,"href":"/docs/device/cnc_manual/","title":"CNC Script Usage Guide","section":"ZIGGO Device","content":"\rCNC Script Usage Guide\r#\r1. Before running the script, configure the following variables in batch.mjs:\r#\r// IP address format: 192.168.137.* // Test data const conf_default = \u0026#34;\u0026lt;configuration name to execute\u0026gt;\u0026#34; // Clock master node const master = 40 const hosts = { device: [43, 44], switch: [40, 41], } Install the necessary dependencies:\nsudo npm install -g zx@4.3.0 pip install -r requirements.txt npm install Configure the environment variables, add the following in .bashrc:\nexport PYTHONPATH=\u0026#34;/home/\u0026lt;username\u0026gt;/scripts\u0026#34; 2. Download the software code for Switch and TSNPerf\r#\r(Remember to configure the ssh public key between the Raspberry Pi and all boards in advance to facilitate password-free login)\n./batch.mjs clone 3. Pull the latest software code and sync it to remote boards\r#\rThe default branch is master, if a specific branch is needed, modify the pull() function in the batch.mjs file, refer to the commented part for details\n// pull all the latest code const pull = async () =\u0026gt; { cd(`${os.homedir()}/repos`) // If you need to specify a branch, similar to the operation of specifying the qbv-test branch below // await $`cd pkt_gen_app; git stash; git checkout qbv-test; git pull origin qbv-test; cd ..` // await $`cd time_sync_app; git stash; git checkout qbv-test; git pull origin qbv-test; cd ..` await Promise.all(hosts.all.map(host =\u0026gt; { const type = hosts.device.includes(host) ? \u0026#39;device\u0026#39; : \u0026#39;switch\u0026#39; if (type === \u0026#39;device\u0026#39;) { return $`rsync -avPh ${os.homedir}/repos/pkt_gen_app root@192.168.137.${host}:~/` } else if (type === \u0026#39;switch\u0026#39;) { return $`rsync -avPh ${os.homedir}/repos/time_sync_app root@192.168.137.${host}:~/;` } })) } Sync to all boards:\n./batch.mjs pull 4. Make all remote boards compile the code\r#\r./batch.mjs build 5. Distribute the configuration files to all boards\r#\r./batch.mjs distribute 6. Start launching the programs on all boards\r#\r./batch.mjs launch 7. Collect statistics on latency and jitter\r#\r./batch.mjs collect "},{"id":18,"href":"/docs/device/testbed/","title":"TestBed Setup Process","section":"ZIGGO Device","content":"\rTestBed Setup Process\r#\rTable of Contents\r#\rTestBed Setup Process Table of Contents Introduction to TestBed Interconnectivity Testing Project Introduction 1. Benchmark Testing 2. Gate Control Capabilities 3. Bandwidth Assurance 4. Gate Control Precision Device Parameter Settings and Deployment TestBed Operation Process Preparation Control Script Preparation Background Traffic Sending Benchmark Testing Gate Control Capabilities Bandwidth Assurance Gate Control Precision Introduction to TestBed\r#\rWe have conducted interconnectivity tests on our internally developed CaaS-Switch, using the following network topology.\nThis demo requires 4 FPGA development boards (2 TSNPerf, 2 CaaS-Switch) and 1 standard PC. If resources are limited or a simplified topology is considered, one CaaS-Switch can be omitted. The PC is responsible for sending background traffic, indicated by black arrows; the left TSNPerf sends test traffic (critical traffic), indicated by red arrows.\nAll test projects generally follow two phases:\nTime Synchronization: Start time synchronization to ensure TSNPerf and CaaS-Switch are under the same clock domain.\nNote: The time synchronization program runs on the TSNPerf and CaaS-Switch systems.\nSending Test Traffic: According to the schedule.json file, TSNPerf sends test traffic.\nInterconnectivity Testing Project Introduction\r#\r1. Benchmark Testing\r#\rObjective: Test the end-to-end delay, packet loss rate, and jitter of high-priority traffic without background traffic as a comparative baseline. Expectation: Delay meets the plan, and jitter is low (around 100ns). 2. Gate Control Capabilities\r#\rObjective: Test the effect of traffic scheduling under general conditions, and the gate control capabilities between two switches. Approach: Background traffic (VLAN priority = 0) is set to line speed, reserving a slot of length 3 for high-priority traffic in each scheduling period. Send 4 packets of high-priority (VLAN priority = 1) test traffic each cycle, each packet 1500Bytes, recording end-to-end average delay, jitter, packet loss rate, and arrival order. Send 8 packets of high-priority (VLAN priority = 1) test traffic each cycle, recording if only n packets pass each cycle. Expectations: Delay, jitter, and packet loss rate consistent with the baseline. When sending 4 packets per cycle, packet loss rate is 0. When sending 8 packets per cycle, only 5 packets pass each cycle (every 8 packets drop 3, as exactly the fifth packet can be sent out in each slot, the remaining three packets are dropped), packet loss rate is 37.5%. 3. Bandwidth Assurance\r#\rObjective: Test the switch\u0026rsquo;s ability to reserve bandwidth and that the priority mapping, operation cycle, and offset of the two switches are essentially consistent. Approach: Background traffic (VLAN priority = 0) is set to line speed (1Gbps), configuring the switch to reserve 50% of the slot for high-priority traffic (VLAN priority = 1), the other 50% only allows low-priority traffic. High-priority (VLAN priority = 1) test traffic is set to line speed (tests show that sending 2752 packets of 1500B each cycle [33ms] nearly reaches 1000Mbps), recording end-to-end average delay, jitter, packet loss rate, and arrival order. High-priority (VLAN priority = 1) test traffic is set to 50% line speed (sending 1376 packets of 1500B each cycle [33ms]), recording end-to-end average delay, jitter, packet loss rate, and arrival order. Expectations: High-priority test traffic at 100% line speed: Delay and jitter consistent with the baseline, packet loss rate around 50%. 2. High-priority test traffic at 50% line speed: Delay and jitter consistent with the baseline, 0 packet loss rate.\n4. Gate Control Precision\r#\rObjective: Test the setting precision of gate control slot length. Approach: (n=1,2,4,8,\u0026hellip;) Reserve a slot of length 1 for high-priority traffic each scheduling period. Send n packets of high-priority (VLAN priority = 1) test traffic each cycle, each packet length of 1/n*1500Byte, recording if n packets pass each cycle. n=1, Expectations: In cases n=1,2,4,8, all packets pass each cycle. If you use our open-source ZIGGO switch and TSNPerf as configured below, you can achieve effects similar to the expected outcomes in the four tests above. If any issues arise, feel free to raise an issue on GitHub.\nDevice Parameter Settings and Deployment\r#\rSwitch software and hardware code is available in the repository ZIGGO-Caas-Switch, use the main branch.\nTSNPerf\u0026rsquo;s software and hardware code are in this repository.\nNote: For bandwidth capability testing, TSNPerf must use the offline_analyze branch; for gate control precision testing, TSNPerf must use the packet_resize branch [for customizing test packet size]. Do not forget to switch branches during testing.\nAll devices\u0026rsquo; IP, MAC, and ID are shown below, corresponding to the JSON configuration file provided later:\nThe corresponding config file can be seen in config.json.\nTestBed Operation Process\r#\rPreparation\r#\rControl Script Preparation\r#\rRefer to CNC-User-Manual\nBackground Traffic Sending\r#\rCan be directly executed on a Linux PC using the send.py script (requires installing scapy, tcpreplay).\nBenchmark Testing\r#\rSwitch and TSNPerf both use the main branch.\nTesting Steps:\nModify batch.mjs to the correct configuration file name. ./batch.mjs pull (ensure correct branch). ./batch.mjs distribute: Each Device sends 4 packets, each Switch reserves 3 slots, distribute the following two configuration files: base/d3s2-baseline-3t-config.json, base/d3s2-baseline-3t-schedule-base.json. ./batch.mjs launch (includes time synchronization and packet sending). ./batch.mjs collect. Gate Control Capabilities\r#\rSwitch and TSNPerf both use the main branch.\nEnable background traffic Device to send packets (not required for benchmark testing). Modify batch.mjs to the correct configuration file name. ./batch.mjs pull (ensure correct branch). ./batch.mjs distribute: Device1 sends 4 packets each time, each Switch reserves 3 slots, distribute the following two configuration files: gate/d3s2-baseline-3t-config.json, gate/d3s2-baseline-3t-schedule-gate.json. ./batch.mjs launch. ./batch.mjs collect. Modify the schedule.json in the above to change the number of packets sent by Device from 4 to 8, then retest from step 4 above, the modified schedule.json is shown below: { \u0026#34;type\u0026#34;: \u0026#34;link\u0026#34;, \u0026#34;from\u0026#34;: 3, \u0026#34;to\u0026#34;: 0, \u0026#34;from_port\u0026#34;: 0, \u0026#34;id\u0026#34;: 7, \u0026#34;schedule\u0026#34;: [ { \u0026#34;period\u0026#34;: 2048, \u0026#34;start\u0026#34;: 0, \u0026#34;end\u0026#34;: 8, \u0026#34;job_id\u0026#34;: 1, \u0026#34;flow_id\u0026#34;: 1 } ] }, Bandwidth Assurance\r#\rSwitch uses the main branch, TSNPerf uses the offline_analyze branch.\nTesting Steps:\nEnable background traffic Device to send packets (not required for benchmark testing).\nModify batch.mjs to the correct configuration file name.\n./batch.mjs pull (ensure correct branch).\n./batch.mjs distribute:\nDevice1 sends 1376 packets each time, each Switch reserves 1024 slots, distribute the following two configuration files: bandwidth/d3s2-baseline-50%t-config.json, bandwidth/d3s2-baseline-50%t-schedule.json. ./batch.mjs launch.\nUse offline analysis.\nModify the schedule.json in the above to change the number of packets sent by Device from 1376 to 2752, then retest from\nstep 4 above, the modified schedule.json is shown below:\n{ \u0026#34;type\u0026#34;: \u0026#34;link\u0026#34;, \u0026#34;from\u0026#34;: 3, \u0026#34;to\u0026#34;: 0, \u0026#34;from_port\u0026#34;: 0, \u0026#34;id\u0026#34;: 7, \u0026#34;schedule\u0026#34;: [ { \u0026#34;period\u0026#34;: 2048, \u0026#34;start\u0026#34;: 0, \u0026#34;end\u0026#34;: 2752, \u0026#34;job_id\u0026#34;: 1, \u0026#34;flow_id\u0026#34;: 1 } ] }, Gate Control Precision\r#\rSwitch uses the main branch, TSNPerf uses the packet_resize branch.\nModify batch.mjs to the correct configuration file name.\n./batch.mjs pull (ensure correct branch).\n./batch.mjs distribute:\nDevice1 sends 1 packet of 1500B each time, each Switch reserves 1 slot, distribute the following two configuration files: accuracy/d3s2-baseline-1t-config.json, accuracy/d3s2-baseline-1t-schedule.json. ./batch.mjs launch.\n./batch.mjs collect.\nModify the schedule.json in the above to change the number of packets sent by Device from 1 to 2, 4, 8 respectively, and the packet size to 750, 375, and 187 respectively, then retest from step 4 above, the modified schedule.json for sending 2 packets is shown below:\n{ \u0026#34;type\u0026#34;: \u0026#34;link\u0026#34;, \u0026#34;from\u0026#34;: 3, \u0026#34;to\u0026#34;: 0, \u0026#34;from_port\u0026#34;: 0, \u0026#34;id\u0026#34;: 7, \u0026#34;schedule\u0026#34;: [ { \u0026#34;period\u0026#34;: 2048, \u0026#34;start\u0026#34;: 0, \u0026#34;end\u0026#34;: 2, \u0026#34;pkt_size\u0026#34;: 750, // 1500/2 = 750 \u0026#34;job_id\u0026#34;: 1, \u0026#34;flow_id\u0026#34;: 1 } ] }, "},{"id":19,"href":"/docs/tsnperf/manual/","title":"TSNPerf Test Content and Usage Table","section":"ZIGGO TSNPerf","content":"\rTSNPerf Test Content and Usage Table\r#\rTraffic Shaping Test\r#\rThis section introduces the method for testing the traffic shaping capabilities of the device under test using TSNPerf. The testing parameters provided in this section are reference configurations and can be modified by users according to actual needs.\nBenchmark Test\r#\rPurpose: To test the end-to-end delay, jitter, and packet loss of high-priority traffic through a single-hop switch (device under test) without background traffic.\nApproach: Use the following topology to send critical packets as described in the configuration document and record the end-to-end latency, jitter, and packet loss rate of the critical packets.\nHere is a reference parameter configuration for the TSNPerf program:\nmode: 0 tx-mode: 2 verbose: true use-ziggo-analysis: false pcap-filename: \u0026#34;/home/i210/launchtimedemo/captured_10w_1500Byte.pcap\u0026#34; interface: \u0026#34;enp1s0\u0026#34; smac: \u0026#34;00:1b:21:77:ac:ae\u0026#34; dmac: \u0026#34;00:1b:21:76:ae:75\u0026#34; ethertype: 0xb62c socket-priority: 0 vlan-priority: 0 offset: 150000 early-offset: 300000 use-launchtime: true basetime: 1684559640000000100L packet-size: 1500 packets-to-send: 10000 interval: 1000000 use-udp: false sip: \u0026#34;192.168.16.10\u0026#34; dip: \u0026#34;192.168.16.11\u0026#34; sport: 10000 dport: 10000 In this configuration, packet-size can be changed as needed, with recommended settings of 64 Byte (minimum Ethernet frame length), 100 Byte, 500 Byte, 1000 Byte, 1500 Byte, etc.\nEach critical packet starts with an 8-byte timestamp from the 26th byte, captured using tcpdump to record the corresponding receive timestamp, thus calculating the end-to-end latency for each packet. By analyzing 10,000 packets sent, average latency and jitter (variance/standard deviation) as well as packet loss rate can be determined.\nGate Control Capabilities\r#\rPurpose: To test the end-to-end delay, jitter, and packet loss rate of high-priority traffic through a single-hop switch (device under test) with background traffic.\nApproach: Use the following topology for testing. Send background traffic from the Injector to the Recorder while simultaneously sending critical traffic from the Publisher to the Recorder, and record the end-to-end latency, jitter, and packet loss rate of the critical packets.\nTo comprehensively test the gate control capabilities of the device under test, adjust the bandwidth of the background traffic injected into the network. For a gigabit network, for instance, examine the conditions where the background traffic is 250 Mbps, 500 Mbps, 750 Mbps, and 1000 Mbps to see how it affects the delay and jitter of the critical packets.\nThe configuration parameters for the TSNPerf program can be referred to the previous section. If the device functions normally, the test results should be consistent with those obtained in the Benchmark Test.\nGate Control Precision\r#\rPurpose: To test the precision of the switch\u0026rsquo;s gate control, i.e., whether it can pass the expected number and size of Ethernet frames.\nApproach: Each cycle reserves a gate control of 16384ns for critical traffic, theoretically allowing 2 packets of 1500Byte Ethernet frames per cycle.\nBelow is a reference parameter configuration for the TSNPerf program:\nmode: 0 tx-mode: 3 verbose: true use-ziggo-analysis: false pcap-filename: \u0026#34;/home/i210/launchtimedemo/captured_10w_1500Byte.pcap\u0026#34; interface: \u0026#34;enp1s0\u0026#34; smac: \u0026#34;00:1b:21:77:ac:ae\u0026#34; dmac: \u0026#34;00:1b:21:76:ae :75\u0026#34; ethertype: 0xb62c socket-priority: 0 vlan-priority: 0 offset: 150000 early-offset: 300000 use-launchtime: false basetime: 1684559640000000100L packet-size: 1500 packets-to-send: 100000 interval: 1000000 use-udp: false sip: \u0026#34;192.168.16.10\u0026#34; dip: \u0026#34;192.168.16.11\u0026#34; sport: 10000 dport: 10000 The Publisher sends full critical traffic to the Recorder, and the Recorder records the timestamps of the received critical packets. It is expected that two critical packets per cycle (1 millisecond) are received.\nAdditionally, the gate control precision of the device can be verified on different topologies with finer granularity. In the topology shown below, for example, with a gigabit Ethernet and 1500Byte test packets, we configure DUT1 to open the critical traffic gate from 0~16us and DUT2 from 15~31us per cycle. The critical packets are expected to pass through the network devices without loss, and the end-to-end delay should be consistent with the results when gates are fully open.\nBandwidth Assurance\r#\rPurpose: To test whether the switch under test can reserve fixed bandwidth for critical traffic.\nApproach:\nConfigure the gate control of the test switch to reserve 25%, 50%, and 75% of the bandwidth for critical data. Send full background traffic from the Injector to the Recorder. Use TSNPerf to send critical traffic from the Publisher to the Recorder, with configuration parameters referable to the previous section. Record the bandwidth usage at the Recorder using tcpdump/wireshark. For a gigabit bandwidth, it is expected that the critical data will occupy bandwidths of 250Mbps, 500Mbps, and 750Mbps respectively. Video Traffic Test\r#\rPurpose: To test the end-to-end delay, jitter, and packet loss rate of video traffic with different Ethernet frame sizes through a single-hop switch.\nApproach: The test topology refers to the Benchmark Test section. Prepare a video traffic pcap file H264.pcap, with TSNPerf program parameters configured as follows:\nmode: 0 tx-mode: 0 verbose: true use-ziggo-analysis: false pcap-filename: \u0026#34;/home/i210/launchtimedemo/H264.pcap\u0026#34; interface: \u0026#34;enp1s0\u0026#34; smac: \u0026#34;00:1b:21:77:ac:ae\u0026#34; dmac: \u0026#34;00:1b:21:76:ae:75\u0026#34; ethertype: 0xb62c socket-priority: 0 vlan-priority: 0 offset: 150000 early-offset: 300000 use-launchtime: true basetime: 1684559640000000100L packet-size: 1500 packets-to-send: 10000 interval: 1000000 use-udp: true sip: \u0026#34;192.168.16.10\u0026#34; dip: \u0026#34;192.168.16.11\u0026#34; sport: 10000 dport: 10000 If the switch under test is a store-and-forward mode, the end-to-end delay of each packet is expected to vary with the size of the packet. If the switch is a cut-through mode, the jitter in the end-to-end delay of the packets is expected to be minimal.\nSummary of Hyperparameters\r#\rIn addition to the TSNPerf program configurations given above, there are some parameters in the test cases that often need to be adjusted according to requirements, now summarized below:\npacket-size: This parameter sets the size of the test packet, used to verify the device\u0026rsquo;s ability to forward different packet sizes. Recommended configurations include: 64 Byte (minimum Ethernet frame length), 100 Byte, 500 Byte, 1000 Byte, 1500 Byte, etc. Background traffic size: This parameter sets the size of background traffic in the network, used to verify whether the device can ensure low latency and low jitter transmission of critical traffic. Depending on the actual network bandwidth size, configure the background traffic to occupy 0%, 25%, 50%, 75%, 100% of the network bandwidth. Topology: The topology determines the path of critical traffic in the network. Testing on different topologies can more comprehensively verify the device\u0026rsquo;s gate control capabilities and gate control precision. Due to space limitations, this article only uses a one-hop "},{"id":20,"href":"/docs/device/contributing/","title":"How to contribute","section":"ZIGGO Device","content":"\rHow to contribute\r#\rReporting a bug\r#\rFile bugs in the Github Issue Tracker. Please follow these guidelines:\nSearch existing issues first, make sure yours hasn\u0026rsquo;t already been reported. Consider enabling debug mode so that you can provide as much details as possible when reporting the issue. Stay on topic, but describe the issue in detail so that others can reproduce it. Provide a screenshot if possible. A screenshot showing the problem is often more useful than a paragraph describing it. The development team will only answer questions on github issues and reject other forms of questions.\nContributing to ZIGGO\u0026rsquo;s code\r#\rIf you want to start contributing to the project\u0026rsquo;s code, please follow these guidelines before creating a pull request:\nThe top post of the pull request should contain a full, self-contained explanation of the feature: what it does, how it does it, with examples of usage and screenshots. Also explain why you want to add this - what problem does it solve. Do not simply add a text Implement feature #4345 , because the information there will most likely be outdated or confusing (multiple discussions and opinions). The pull request needs to be self-contained. Bug fixes are always welcome. A good way to easily start contributing is to pick and work on a good first issue. We try to make these issues as clear as possible and provide basic info on how the code should be changed, and if something is unclear feel free to ask for more information on the issue. Before adding a new feature, ask about it in the Github Issue Tracker , or check if existing discussions exist to make sure the new functionality is desired. Pull requests that make many changes using an automated tool, like for spell fixing, styling, etc. will not be accepted. Pull requests that address multiple issues will most likely stall and eventually be closed. This is because we might be fine with one of the changes but not with others and untangling that kind of pull request is too much hassle both for maintainers and the person who submitted it. So most of the time someone gives up and the PR gets closed. So please keep the pull request focused on one issue. Do not mark your reviewer\u0026rsquo;s comments as \u0026ldquo;resolved\u0026rdquo;. If you do that, the comments will be hidden and the reviewer will not know what are the pending issues in the pull request. Only the reviewer should resolve the comments. "},{"id":21,"href":"/docs/tsnperf/report/","title":"Report for Brand A Switch","section":"ZIGGO TSNPerf","content":"\rReport for Brand A Switch\r#\rReport is here.(In Chinese)\n"},{"id":22,"href":"/docs/device/","title":"ZIGGO Device","section":"Docs","content":" ZIGGO Device: A flexible and standard-compliant toolkit for TSN performance evaluation.\r#\rTable of Contents\r#\rZIGGO Device: A flexible and standard-compliant toolkit for TSN performance evaluation. Table of Contents Introduction ZIGGO Open Platform Demo Features Read before start Getting Started System Design Demo APP Tutorial License and Citation TODO List Contributing Introduction\r#\rZIGGO is a flexible, standard-compliant, and control-function-virtualized TSN switch platform ready for industrial control, automotive electronics, and other time-sensitive applications.\nThis is the document for the ZIGGO Device. (We also offer ZIGGO-CaaS-Switch that comply with the IEEE 802.1 TSN standard.) Our Device supports testing all standards-compliant switches.\nZIGGO Open Platform\r#\rThe construction of the ZIGGO Open Platform consists of three levels: network device, management tools, and a Demo App:\nThe software and hardware projects, along with the development board startup tutorial, provide instructions for setting up an individual network device.\nThe CNC User Manual and Device User Manual cover system configuration and management tools.\nLastly, we offer a comprehensive Demo App building tutorial that instructs how to collaboratively build a complete and functional Demo using network devices and management tools.\nDemo\r#\rWe provide a demonstration video of the TSN switch. It demonstrates the superior performance of the ZIGGO-CaaS-Switch compared to the normal switch.\nThe left side of the picture is the ZYNQ development board we use, and the right side is the TSN display board we built.\nClick the pic to watch the video! Or just click here.\nFeatures\r#\rZIGGO supports the simultaneous transmission of both Information Technology (IT) and Operation Technology (OT) data traffic with QoS guarantee.\nZIGGO complies with IEEE standards 802.1AS, Qav, Qbv, and Qcc.\nZIGGO provides Real-time and Deterministic Ethernet transport\nZIGGO achieve Zero Packet Loss , Microsecond-level Latency with Nanosecond-level Jitter Gate Ability. ZIGGO guarantee Gigabit Throughput. ZIGGO provide gate accuracy applicable to All Ethernet Frame Sizes. Read before start\r#\rGetting started with ZIGGO-CaaS-Switch/ZIGGO-Device is a pretty hard task. Users/developers need to have sufficient basic knowledge and be prepare to for a long periond of learning and debugging.\nPlease refer to basic_knowledge.md to check if you have ability to use ZIGGO competently.\nGetting Started\r#\rPlease refer to required.md to get prepared.\nAfter that, please refer to getting_started.md for the build and run a single ZIGGO Device.\nSystem Design\r#\rZIGGO is implemented on ZYNQ-7000 SoC and exploits ZYNQ\u0026rsquo;s both hardware and software programmability.\nWe also provide more in-depth documentation explaining specific design principles for ZIGGO Device.\nDemo APP Tutorial\r#\rWe also provide a testbed build document that allows you to build a real-time Ethernet system using the ZIGGO swtich and Device.\nThrough this platform, we can measure the delay and jitter of TSN time-critcial traffic, the switch\u0026rsquo;s gating capability, bandwidth guarantee and gating accuracy.\nReplacing ZIGGO CaaS switches with commercial TSN switches can also test its above capabilities.\nLicense and Citation\r#\rZIGGO is released under a MIT license.\nPlease consider citing our papers if the project helps your research with the following BibTex:\n@inproceedings{caas, author={Yang, Zheng and Zhao, Yi and Dang, Fan and He, Xiaowu and Wu, Jiahang and Cao, Hao and Wang, Zeyu and Liu, Yunhao}, booktitle={IEEE INFOCOM 2023 - IEEE Conference on Computer Communications}, title={CaaS: Enabling Control-as-a-Service for Time-Sensitive Networking}, year={2023}, pages={1-10}, doi={10.1109/INFOCOM53939.2023.10228980}} @inproceedings{etsn, author={Zhao, Yi and Yang, Zheng and He, Xiaowu and Wu, Jiahang and Cao, Hao and Dong, Liang and Dang, Fan and Liu, Yunhao}, booktitle={IEEE ICDCS 2022 - IEEE International Conference on Distributed Computing Systems}, title={E-TSN: Enabling Event-triggered Critical Traffic in Time-Sensitive Networking for Industrial Applications}, year={2022}, volume={}, number={}, pages={691-701}, doi={10.1109/ICDCS54860.2022.00072}} TODO List\r#\rZIGGO CaaS Switch Release ZIGGO Device Release ZIGGO Device Source Code Tutorial for build a testbed Test Case for TSN We will expand each test in the tutorial to multiple test cases to cover different edge cases and comprehensively test the performance of TSN switches.\nSupport Device List At present, we have only tested our own Ziggo switches and are testing other commercial switches (such as Huawei ,H3C and NXP). We expect to maintain a list of test results in the future.\nContributing\r#\rPlease see the guide for information on how to ask for help or contribute to the development of ZIGGO!\nThe development team will only answer questions on github issues and reject other forms of questions.\n"},{"id":23,"href":"/docs/","title":"Docs","section":"","content":"\rhanbao\r#\r123\r#\r"},{"id":24,"href":"/menu/","title":"Index","section":"","content":" +++ headless = true +++\n"}]